<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF → Word (.docx) Converter (Browser)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px;max-width:900px}
    .card{border:1px solid #ddd;border-radius:12px;padding:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    button{padding:10px 14px;border:0;border-radius:10px;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    .primary{background:#0b74ff;color:#fff}
    .muted{color:#666;font-size:14px;line-height:1.4}
    progress{width:100%;height:14px}
    .log{white-space:pre-wrap;background:#f7f7f7;border:1px solid #eee;border-radius:10px;padding:10px;margin-top:12px;font-size:13px}
    .warn{background:#fff7e6;border:1px solid #ffe2a8;padding:10px;border-radius:10px;margin-top:12px}
    code{background:#f2f2f2;padding:2px 6px;border-radius:6px}
  </style>
</head>
<body>
  <h1>PDF → Word (.docx) Converter</h1>

  <div class="card">
    <div class="row">
      <input id="pdfFile" type="file" accept="application/pdf" />
      <button id="convertBtn" class="primary" disabled>Convert to Word</button>
      <button id="downloadBtn" disabled>Download .docx</button>
    </div>

    <div class="warn">
      <div><strong>Important limitations</strong></div>
      <div class="muted">
        This is a <b>client-side</b> converter. It extracts PDF text and rebuilds a Word file.
        <b>It will not perfectly preserve layout</b> (columns, tables, exact spacing, fonts).
        If your PDF is scanned images, you’ll need OCR (not included here).
      </div>
    </div>

    <div style="margin-top:14px">
      <progress id="prog" value="0" max="100"></progress>
      <div id="status" class="muted" style="margin-top:6px">Load a PDF to begin.</div>
      <div id="log" class="log"></div>
    </div>
  </div>

  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js"></script>
  <script>
    // pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.min.js";
  </script>

  <!-- docx (Word .docx builder) -->
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>

  <!-- FileSaver (save blob) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const pdfInput = $("pdfFile");
    const convertBtn = $("convertBtn");
    const downloadBtn = $("downloadBtn");
    const prog = $("prog");
    const status = $("status");
    const logEl = $("log");

    let lastDocBlob = null;
    let lastName = "converted.docx";

    function setStatus(msg) { status.textContent = msg; }
    function appendLog(msg) { logEl.textContent += msg + "\n"; }
    function setProgress(pct) { prog.value = Math.max(0, Math.min(100, pct)); }

    pdfInput.addEventListener("change", () => {
      lastDocBlob = null;
      downloadBtn.disabled = true;
      logEl.textContent = "";
      if (pdfInput.files && pdfInput.files[0]) {
        convertBtn.disabled = false;
        setStatus(`Selected: ${pdfInput.files[0].name}`);
        lastName = pdfInput.files[0].name.replace(/\.pdf$/i, "") + ".docx";
      } else {
        convertBtn.disabled = true;
        setStatus("Load a PDF to begin.");
      }
    });

    downloadBtn.addEventListener("click", () => {
      if (!lastDocBlob) return;
      saveAs(lastDocBlob, lastName);
    });

    // Group text items into lines using the Y position (simple heuristic).
    function itemsToLines(items) {
      // Each item has transform [a,b,c,d,e,f], where e=x, f=y
      const normalized = items
        .filter(it => it.str && it.str.trim().length)
        .map(it => ({
          text: it.str,
          x: it.transform[4],
          y: it.transform[5],
          w: it.width || 0
        }))
        .sort((a,b) => (b.y - a.y) || (a.x - b.x)); // top-to-bottom (PDF y increases upward), then left-to-right

      const linesMap = new Map();
      const yTolerance = 2; // tweak if needed

      for (const it of normalized) {
        // bucket by rounded y (tolerance)
        let key = null;
        for (const k of linesMap.keys()) {
          if (Math.abs(k - it.y) <= yTolerance) { key = k; break; }
        }
        if (key === null) key = it.y;
        if (!linesMap.has(key)) linesMap.set(key, []);
        linesMap.get(key).push(it);
      }

      // build lines
      const lineKeys = Array.from(linesMap.keys()).sort((a,b) => b - a); // top-to-bottom
      const lines = [];

      for (const y of lineKeys) {
        const row = linesMap.get(y).sort((a,b) => a.x - b.x);
        let line = "";
        let prevX = null;

        for (const chunk of row) {
          // add space if there is a gap
          if (prevX !== null && (chunk.x - prevX) > 6 && !line.endsWith(" ")) line += " ";
          line += chunk.text;
          prevX = chunk.x + (chunk.w || 0);
        }

        // cleanup multiple spaces
        line = line.replace(/\s+/g, " ").trim();
        if (line) lines.push(line);
      }

      return lines;
    }

    convertBtn.addEventListener("click", async () => {
      const file = pdfInput.files?.[0];
      if (!file) return;

      convertBtn.disabled = true;
      downloadBtn.disabled = true;
      lastDocBlob = null;
      logEl.textContent = "";
      setProgress(0);

      try {
        setStatus("Reading PDF...");
        appendLog("Reading file…");

        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        const pdf = await loadingTask.promise;

        const total = pdf.numPages;
        appendLog(`Pages: ${total}`);
        setStatus(`Extracting text from ${total} pages…`);

        const docChildren = [];
        // Optional: a title paragraph (comment out if you don't want it)
        // docChildren.push(new docx.Paragraph({ text: file.name, heading: docx.HeadingLevel.HEADING_1 }));

        for (let pageNo = 1; pageNo <= total; pageNo++) {
          setStatus(`Processing page ${pageNo}/${total}…`);
          setProgress(Math.round(((pageNo - 1) / total) * 100));

          const page = await pdf.getPage(pageNo);
          const textContent = await page.getTextContent();

          const lines = itemsToLines(textContent.items);
          appendLog(`Page ${pageNo}: ${lines.length} line(s)`);

          // Add page lines as paragraphs
          for (const line of lines) {
            docChildren.push(
              new docx.Paragraph({
                children: [new docx.TextRun({ text: line })]
              })
            );
          }

          // Page break between pages
          if (pageNo < total) {
            docChildren.push(new docx.Paragraph({ children: [new docx.PageBreak()] }));
          }
        }

        setStatus("Building .docx…");
        setProgress(95);

        const doc = new docx.Document({
          sections: [{
            properties: {},
            children: docChildren
          }]
        });

        const blob = await docx.Packer.toBlob(doc);
        lastDocBlob = blob;

        setProgress(100);
        setStatus("Done. Click Download .docx");
        downloadBtn.disabled = false;
      } catch (err) {
        console.error(err);
        setStatus("Error: " + (err?.message || String(err)));
        appendLog("ERROR: " + (err?.stack || err?.message || String(err)));
      } finally {
        convertBtn.disabled = false;
      }
    });
  </script>
</body>
</html>

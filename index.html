<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Orbit</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --line:rgba(17,24,39,.18);
      --lineHot:rgba(17,24,39,.55);
      --glow:rgba(17,24,39,.10);
      --btnBorder:rgba(17,24,39,.14);
      --btnHover:rgba(17,24,39,.06);
      --tipBg:rgba(255,255,255,.85);
      --tipBorder:rgba(17,24,39,.14);

      --overlay: rgba(17,24,39,.55);
      --cardBg: rgba(255,255,255,.92);
      --cardBorder: rgba(17,24,39,.10);

      /* dynamic */
      --topbarH: 92px;

      /* mobile layout vars */
      --mobilePanelPad: 12px;
      --mobilePanelGap: 10px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow:hidden;
      min-height:100vh;
    }

    .topbar{
      position:fixed;
      top:14px; left:14px; right:14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      z-index:30;
      pointer-events:none;
    }
    .brand{display:flex;align-items:center;gap:10px;user-select:none;pointer-events:auto}
    .brand .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--ink);
      box-shadow: 0 0 18px var(--glow);
      opacity:.9;
    }
    .brand h1{
      margin:0;
      font-size:14px;
      letter-spacing:.10em;
      text-transform:uppercase;
      opacity:.88;
      white-space:nowrap;
    }
    .actions{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:8px;
      pointer-events:auto;
    }
    .btn{
      appearance:none;
      border:1px solid var(--btnBorder);
      background: rgba(17,24,39,.03);
      color: var(--ink);
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      text-decoration:none;
      font-weight:800;
      letter-spacing:.02em;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
      line-height:1;
      white-space:nowrap;
      touch-action: manipulation;
    }
    .btn:hover{transform: translateY(-1px);background: var(--btnHover);border-color: rgba(17,24,39,.22)}
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn .miniDot{
      width:7px;height:7px;border-radius:50%;
      background: rgba(17,24,39,.85);
      box-shadow: 0 0 12px var(--glow);
      opacity:.9;
    }

    /* Desktop side panel (right) */
    .sidePanel{
      position:fixed;
      right:14px;
      top: calc(14px + var(--topbarH, 92px));
      z-index:28;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:10px;
    }
    .panelCard{
      pointer-events:auto;
      width:min(360px, calc(100vw - 28px));
      border-radius:16px;
      background: rgba(255,255,255,.80);
      box-shadow: 0 0 0 1px rgba(17,24,39,.06) inset;
      padding:10px;
      backdrop-filter: blur(6px);
    }
    .row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .input{
      border:1px solid rgba(17,24,39,.14);
      background: rgba(255,255,255,.75);
      color: var(--ink);
      padding:12px 12px;
      border-radius:999px;
      outline:none;
      flex:1;
      min-width: 200px;
      font-size:16px; /* ✅ prevents iOS zoom on focus */
    }
    .smallBtn{
      border:1px solid rgba(17,24,39,.14);
      background: rgba(255,255,255,.75);
      color: var(--ink);
      padding:10px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      line-height:1;
      white-space:nowrap;
      touch-action: manipulation;
    }
    .smallBtn:hover{transform: translateY(-1px);background: rgba(17,24,39,.04);border-color: rgba(17,24,39,.22)}
    .status{
      margin-top:10px;
      color: rgba(17,24,39,.60);
      font-size:13px;
      white-space:pre-wrap;
      line-height:1.35;
      max-height: 170px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }

    .scene{
      position:fixed;
      inset:0;
      background:
        radial-gradient(1200px 900px at 50% 45%, rgba(17,24,39,.05), rgba(255,255,255,0) 65%),
        #fff;
      overflow:hidden;
    }
    .scene:before{
      content:"";
      position:absolute; inset:-20%;
      background-image: radial-gradient(rgba(17,24,39,.08) 1px, transparent 1px);
      background-size: 3px 3px;
      opacity:.05;
      transform: rotate(7deg);
      pointer-events:none;
    }

    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}
    #fx{z-index:1}
    #lines{z-index:2}

    .centerLabel{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      text-align:center;
      z-index:7;
      pointer-events:none;
      user-select:none;
      width:min(360px, 80vw);
    }
    .centerLabel .title{
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-size:12px;
      opacity:.85;
    }
    .centerLabel .sub{
      margin-top:6px;
      font-size:12px;
      color: rgba(17,24,39,.60);
      opacity:.95;
    }

    .branches{position:absolute; inset:0; z-index:8;}

    .branch{
      position:absolute;
      left:50%;
      top:50%;
      width:0;height:0;
      transform: translate(-50%,-50%) rotate(var(--angle)) translateX(var(--r0));
      transform-origin: 0 0;
      pointer-events:auto;
    }
    .branch .hit{
      position:absolute;
      left:0;
      top:-26px;
      width: var(--len);
      height: 52px; /* ✅ bigger tap target */
      cursor:pointer;
      background: transparent;
      -webkit-tap-highlight-color: transparent;
    }
    .branch .line{
      position:absolute;
      left:0; top:0;
      height:2px;
      width: var(--lenShort);
      background: var(--line);
      border-radius:999px;
      transform-origin:left center;
      transition: width .22s ease, background .22s ease, box-shadow .22s ease;
      box-shadow: 0 0 12px rgba(17,24,39,.06);
      opacity:.9;
    }

    .branch .node{
      position:absolute;
      left: calc(var(--lenShort) - 18px);
      top: -18px;
      width: 36px;
      height: 36px;
      transform: scale(.25);
      opacity: 0;
      transition: transform .22s ease, opacity .22s ease, left .22s ease, filter .22s ease;
      cursor:pointer;
      background: transparent;
      filter: drop-shadow(0 10px 16px rgba(17,24,39,.10));
      animation: pillFloat 2.9s ease-in-out infinite;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .branch .node.alt{ animation-duration: 3.4s; animation-delay: -1.2s; }

    .branch .node::before{
      content:"";
      position:absolute; inset:0;
      border-radius:999px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.55), inset 0 -10px 18px rgba(17,24,39,.08);
      background: linear-gradient(135deg, rgba(17,24,39,.08), rgba(255,255,255,.9));
    }
    .branch .node.capsule{ animation-name: capsuleDrift; }
    .branch .node.capsule::before{
      background:
        linear-gradient(90deg, rgba(17,24,39,.18) 0 50%, rgba(17,24,39,.06) 50% 100%),
        linear-gradient(135deg, rgba(17,24,39,.12), rgba(255,255,255,.95));
    }
    .branch .node.capsule::after{
      content:"";
      position:absolute; left:50%; top:6px; bottom:6px; width:1px;
      transform: translateX(-50%);
      background: rgba(17,24,39,.28);
      opacity:.55; border-radius:999px;
    }
    .branch .node.tablet{ border-radius: 14px; animation-name: tabletDrift; }
    .branch .node.tablet::before{
      border-radius: 14px;
      background:
        linear-gradient(180deg, rgba(255,255,255,.95), rgba(17,24,39,.06)),
        linear-gradient(135deg, rgba(17,24,39,.10), rgba(255,255,255,.9));
    }
    .branch .node.tablet::after{
      content:"";
      position:absolute; left:7px; right:7px; top:50%; height:1px;
      transform: translateY(-50%);
      background: rgba(17,24,39,.25);
      opacity:.55; border-radius:999px;
    }

    @keyframes pillFloat{
      0%,100%{ transform: translateY(0) scale(var(--pillScale,1)); }
      50%{ transform: translateY(-2px) scale(var(--pillScale,1)); }
    }
    @keyframes capsuleDrift{
      0%,100%{ transform: translateY(0) rotate(-8deg) scale(var(--pillScale,1)); }
      50%{ transform: translateY(-3px) rotate(8deg) scale(var(--pillScale,1)); }
    }
    @keyframes tabletDrift{
      0%,100%{ transform: translateY(0) rotate(10deg) scale(var(--pillScale,1)); }
      50%{ transform: translateY(-3px) rotate(-10deg) scale(var(--pillScale,1)); }
    }

    .branch:hover .line{
      width: var(--len);
      background: var(--lineHot);
      box-shadow: 0 0 26px rgba(17,24,39,.12);
    }
    .branch:hover .node{
      left: calc(var(--len) - 18px);
      opacity: 1;
      transform: scale(1);
      --pillScale: 1;
      filter: drop-shadow(0 14px 22px rgba(17,24,39,.14));
    }
    .branch:hover .node:hover{
      transform: scale(1.08);
      filter: drop-shadow(0 18px 28px rgba(17,24,39,.18));
    }

    .tip{
      position:absolute;
      left: calc(var(--len) + 18px);
      top: -10px;
      transform: rotate(calc(var(--angle) * -1));
      transform-origin:left center;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--tipBorder);
      background: var(--tipBg);
      backdrop-filter: blur(6px);
      color: rgba(17,24,39,.85);
      font-size:12px;
      white-space:nowrap;
      max-width: 420px;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .branch:hover .tip{
      opacity:1;
      transform: rotate(calc(var(--angle) * -1)) translateY(-2px);
    }

    /* ---------- PREVIEW MODAL ---------- */
    .modal{
      position:fixed; inset:0;
      background: var(--overlay);
      z-index:60;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
    }
    .modal.show{display:flex}
    .modalCard{
      width:min(1100px, 96vw);
      height:min(720px, 92vh);
      background: var(--cardBg);
      border:1px solid var(--cardBorder);
      border-radius:18px;
      backdrop-filter: blur(10px);
      box-shadow: 0 22px 70px rgba(0,0,0,.22);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-bottom:1px solid rgba(17,24,39,.10);
      flex-wrap:wrap; /* ✅ wraps on small screens */
    }
    .modalTitle{
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      font-size:12px;
      opacity:.85;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 100%;
    }
    .modalBtns{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .modalBtn{
      border:1px solid rgba(17,24,39,.16);
      background: rgba(255,255,255,.75);
      padding:10px 12px; /* ✅ better touch */
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.02em;
      line-height:1;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      text-decoration:none;
      color: var(--ink);
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      touch-action: manipulation;
    }
    .modalBtn:hover{transform: translateY(-1px);background: rgba(17,24,39,.04);border-color: rgba(17,24,39,.22)}
    .modalBtn:active{transform: translateY(0px) scale(.99)}
    .modalBody{flex:1; background:#fff}
    .modalBody iframe{
      width:100%; height:100%;
      border:0;
      background:#fff;
    }
    .modalHint{
      padding:10px 12px;
      border-top:1px solid rgba(17,24,39,.10);
      color: rgba(17,24,39,.60);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .modalHint .mono{font-family: ui-monospace, Menlo, Consolas, monospace; word-break:break-all;}
    .kbd{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      border:1px solid rgba(17,24,39,.18);
      background: rgba(255,255,255,.75);
      border-radius:10px;
      padding:2px 8px;
      font-size:12px;
      opacity:.9;
    }

    /* ✅ PHONE LAYOUT: make panel full-width under topbar */
    @media (max-width: 780px){
      body{overflow:hidden;}
      .topbar{
        left: var(--mobilePanelPad);
        right: var(--mobilePanelPad);
        top: var(--mobilePanelPad);
      }
      .brand h1{font-size:13px}
      .actions{gap:8px}
      .btn{padding:10px 12px}

      .sidePanel{
        left: var(--mobilePanelPad);
        right: var(--mobilePanelPad);
        align-items:stretch;
        top: calc(var(--mobilePanelPad) + var(--topbarH, 92px) + var(--mobilePanelGap));
      }
      .panelCard{
        width:100%;
        border-radius:18px;
      }
      .row{justify-content:flex-start}
      .input{min-width: 0; width: 100%;}
      .smallBtn{width:auto}

      /* give the center label a little lift so it doesn't sit under the panel */
      .centerLabel{
        top: 56%;
      }

      /* reduce tip width on phones */
      .tip{max-width: 260px;}
    }

    /* ✅ make hover behavior always "expanded" on touch devices */
    @media (hover:none){
      .branch .line{ width: var(--len); background: var(--lineHot); }
      .branch .node{ left: calc(var(--len) - 18px); transform: scale(1); opacity:1; }
      .branch .tip{ opacity:1; }
    }
  </style>
</head>
<body>
  <div class="scene" id="scene">
    <canvas id="fx"></canvas>
    <canvas id="lines"></canvas>

    <div class="centerLabel" aria-hidden="true">
      <div class="title">Octopus Docs</div>
      <div class="sub" id="countSub">Loading…</div>
    </div>

    <div class="branches" id="branches"></div>
  </div>

  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <h1>PDF ORBIT</h1>
    </div>
    <div class="actions">
      <a class="btn" href="./index2.html"><span class="miniDot"></span>Edit</a>
      <a class="btn" href="./index3.html"><span class="miniDot"></span>Tutorials</a>
      <a class="btn"
         href="https://script.google.com/macros/s/AKfycbz1o39V5VcbA5x4gzxA__uLAGKalQJOLqbyStGoFBML5VK5A7exuGYNbyD4S8ApIfvEXQ/exec"
         target="_blank" rel="noopener noreferrer"><span class="miniDot"></span>Settings</a>
    </div>
  </div>

  <div class="sidePanel">
    <div class="panelCard">
      <div class="row">
        <input class="input" id="q" placeholder="Search filename..." />
        <button class="smallBtn" id="reload">Reload</button>
      </div>
      <div class="status" id="status">Loading from GitHub…</div>
    </div>
  </div>

  <!-- ✅ Preview modal -->
  <div class="modal" id="modal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Preview</div>
        <div class="modalBtns">
          <a class="modalBtn" id="downloadBtn" href="#" download>
            <span style="width:7px;height:7px;border-radius:50%;background:rgba(17,24,39,.85);display:inline-block"></span>
            Download
          </a>
          <button class="modalBtn" id="openNewBtn" type="button">Open in new tab</button>
          <button class="modalBtn" id="closeBtn" type="button">Close <span class="kbd">Esc</span></button>
        </div>
      </div>
      <div class="modalBody">
        <iframe id="viewer" title="PDF Preview"></iframe>
      </div>
      <div class="modalHint">
        <div>Click <b>Download</b> only after preview.</div>
        <div class="mono" id="modalLink"></div>
      </div>
    </div>
  </div>

<script>
const OWNER  = "a860h040";
const REPO   = "Education";
const BRANCH = "main";
const FOLDER = "pdfs";
const API = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(FOLDER)}?ref=${encodeURIComponent(BRANCH)}`;
const TEXTURE_URL = "./assets/roof.png";

/* PDF.js viewer hosted by Mozilla */
const PDFJS_VIEWER = "https://mozilla.github.io/pdf.js/web/viewer.html?file=";

const scene = document.getElementById("scene");
const fx = document.getElementById("fx");
const lines = document.getElementById("lines");
const statusEl = document.getElementById("status");
const branchesEl = document.getElementById("branches");
const q = document.getElementById("q");
const countSub = document.getElementById("countSub");

/* modal refs */
const modal = document.getElementById("modal");
const viewer = document.getElementById("viewer");
const modalTitle = document.getElementById("modalTitle");
const modalLink = document.getElementById("modalLink");
const downloadBtn = document.getElementById("downloadBtn");
const openNewBtn = document.getElementById("openNewBtn");
const closeBtn = document.getElementById("closeBtn");

let allFiles = [];
let shownFiles = [];
let branchObjs = [];
let rafId = 0;

let texImg = null;
let texPattern = null;

/* pills swimming inside center blob */
let swimPills = [];
let lastFrameT = 0;

function setStatus(t){ statusEl.textContent = t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function hashStr(str){
  let h=2166136261;
  for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
  return ((h>>>0) % 100000) / 100000;
}

/* ✅ measure topbar and set CSS var so sidePanel never overlaps */
function updateSidePanelOffset(){
  const topbar = document.querySelector(".topbar");
  if (!topbar) return;
  const h = topbar.getBoundingClientRect().height;
  document.documentElement.style.setProperty("--topbarH", `${Math.ceil(h) + 10}px`);
}

function resizeCanvas(c){
  const r = scene.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  c.width = Math.floor(r.width * dpr);
  c.height = Math.floor(r.height * dpr);
  const ctx = c.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { w:r.width, h:r.height };
}

function displayName(full){
  const name = String(full || "");
  const noExt = name.toLowerCase().endsWith(".pdf") ? name.slice(0, -4) : name;
  const parts = noExt.split("_");
  if (parts.length >= 3) return parts.slice(2).join("_").trim() || noExt.trim();
  return noExt.trim();
}

/* ✅ PREVIEW modal */
function previewFile(url, niceName){
  modalTitle.textContent = niceName || "Preview";
  modalLink.textContent = url;

  downloadBtn.href = url;
  downloadBtn.setAttribute("download", (niceName ? niceName.replace(/[\\/:*?"<>|]/g,"-") : "file") + ".pdf");

  const encoded = encodeURIComponent(url);
  viewer.src = PDFJS_VIEWER + encoded;

  const fallbackTimer = setTimeout(() => {
    try{
      if (!viewer.contentWindow || viewer.contentWindow.location.href === "about:blank"){
        viewer.src = url;
      }
    }catch(e){
      viewer.src = url;
    }
  }, 900);

  openNewBtn.onclick = () => window.open(url, "_blank", "noopener,noreferrer");
  showModal(true);
  modal._fallbackTimer = fallbackTimer;
}

function showModal(on){
  if (on){
    modal.classList.add("show");
    modal.setAttribute("aria-hidden","false");
  } else {
    modal.classList.remove("show");
    modal.setAttribute("aria-hidden","true");
    viewer.src = "about:blank";
    if (modal._fallbackTimer) clearTimeout(modal._fallbackTimer);
  }
}

closeBtn.addEventListener("click", () => showModal(false));
modal.addEventListener("click", (e) => {
  if (e.target === modal) showModal(false);
});
window.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && modal.classList.contains("show")) showModal(false);
});

function wavyRadius(angle, t, R){
  const n =
    Math.sin(angle*3 + t*0.9)*0.18 +
    Math.sin(angle*7 - t*1.3)*0.10 +
    Math.sin(angle*13 + t*0.6)*0.06;
  const spike = Math.max(0, Math.sin(angle*18 + t*1.2)) * 0.10;
  return R * (1 + n*0.35 + spike);
}

function buildTexturePattern(ctx){
  if (!texImg || !texImg.naturalWidth) return null;
  const scale = 0.32;
  const oc = document.createElement("canvas");
  oc.width = Math.max(64, Math.floor(texImg.naturalWidth * scale));
  oc.height = Math.max(64, Math.floor(texImg.naturalHeight * scale));
  const octx = oc.getContext("2d");
  octx.drawImage(texImg, 0, 0, oc.width, oc.height);
  return ctx.createPattern(oc, "repeat");
}
async function loadTexture(){
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => { texImg = img; resolve(true); };
    img.onerror = () => { texImg = null; resolve(false); };
    img.src = TEXTURE_URL;
  });
}

/* top & bottom branches shorter */
function topBottomScale(angleDeg){
  const a = ((angleDeg % 360) + 360) % 360;
  const distTop = Math.min(Math.abs(a - 270), Math.abs(a - (270+360)));
  const distBot = Math.abs(a - 90);
  const influence = Math.max(0, 1 - (Math.min(distTop, distBot) / 85));
  const scale = 1 - influence * 0.50;
  return clamp(scale, 0.5, 1.0);
}

/* safe geometry: on phones reserve NO right panel width */
function computeSafeGeometry(fileCount){
  const r = scene.getBoundingClientRect();
  const w = r.width, h = r.height;

  const isPhone = window.matchMedia("(max-width: 780px)").matches;

  const safePad = isPhone ? 44 : 72;
  const topHud = isPhone ? 140 : 80; /* more space for full-width search card */
  const rightPanelW = isPhone ? 0 : (Math.min(360, w * 0.38) + 24);

  const availW = (w - safePad*2) - rightPanelW;
  const availH = (h - safePad) - topHud;

  const R = Math.min(availW, availH) * (isPhone ? 0.25 : 0.28);
  const r0 = R * 1.05;

  const maxToEdge = Math.min(availW, availH) * 0.50;
  const baseLen = clamp(maxToEdge, isPhone ? 150 : 200, isPhone ? 300 : 380);
  const jitter = baseLen * 0.18;

  const crowd = clamp(fileCount / 22, 0, 1);
  const baseLen2 = baseLen * (1 - crowd*0.18);

  return { R, r0, baseLen: baseLen2, jitter };
}

function buildBranches(files){
  branchesEl.innerHTML = "";
  branchObjs = [];

  const geom = computeSafeGeometry(files.length);
  const r0 = geom.r0;

  const MAX = 22;
  const list = files.slice(0, MAX);

  const baseLen = geom.baseLen;
  const jitter  = geom.jitter;
  const shortFactor = 0.52;
  const minAngleGap = 12;

  const golden = 137.50776405;
  const usedAngles = [];

  list.forEach((f, i) => {
    const seed = hashStr(f.name);
    let ang = (i * golden + seed * 30) % 360;

    for (let tries=0; tries<30; tries++){
      const ok = usedAngles.every(a => {
        const d = Math.abs(((ang - a + 540) % 360) - 180);
        return d >= minAngleGap;
      });
      if (ok) break;
      ang = (ang + 9) % 360;
    }
    usedAngles.push(ang);

    const tb = topBottomScale(ang);
    const lenBase = clamp(baseLen + (seed - 0.5) * 2 * jitter, baseLen*0.78, baseLen*1.08);
    const len = lenBase * tb;
    const lenShort = len * shortFactor;

    const nice = displayName(f.name);
    const url = f.download_url || f.raw_url;

    const branch = document.createElement("div");
    branch.className = "branch";
    branch.style.setProperty("--angle", ang + "deg");
    branch.style.setProperty("--len", len + "px");
    branch.style.setProperty("--lenShort", lenShort + "px");
    branch.style.setProperty("--r0", r0 + "px");

    const lineEl = document.createElement("div"); lineEl.className = "line";
    const nodeEl = document.createElement("div");
    nodeEl.className = "node " + (i % 2 === 0 ? "capsule" : "tablet") + (i % 3 === 0 ? " alt" : "");
    const hitEl  = document.createElement("div"); hitEl.className  = "hit"; hitEl.title = nice;
    const tip    = document.createElement("div"); tip.className    = "tip"; tip.textContent = nice;

    const openPreview = () => previewFile(url, nice);
    hitEl.addEventListener("click", openPreview);
    nodeEl.addEventListener("click", openPreview);
    hitEl.addEventListener("touchstart", (e)=>{ e.preventDefault(); openPreview(); }, {passive:false});

    branch.appendChild(lineEl);
    branch.appendChild(nodeEl);
    branch.appendChild(hitEl);
    branch.appendChild(tip);
    branchesEl.appendChild(branch);

    branchObjs.push({ angleRad: ang * Math.PI/180, angleDeg: ang, len, lenShort, seed, el: branch });
  });

  countSub.textContent = files.length ? `${files.length} file(s)` : "No PDFs found";
}

async function load(){
  setStatus("Loading from GitHub…");
  countSub.textContent = "Loading…";

  try{
    const r = await fetch(API);
    if (!r.ok){
      const text = await r.text();
      setStatus(`ERROR: GitHub API ${r.status}\n${text}\n\nIf your repo is PRIVATE, preview/listing will fail on GitHub Pages.`);
      allFiles = [];
      buildBranches([]);
      return;
    }

    const data = await r.json();
    allFiles = (Array.isArray(data) ? data : [])
      .filter(x => x && x.type === "file" && (x.name||"").toLowerCase().endsWith(".pdf"))
      .map(x => ({
        name: x.name,
        download_url: x.download_url,
        raw_url: `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${x.path}`
      }))
      .sort((a,b)=> displayName(a.name).localeCompare(displayName(b.name)));

    setStatus(`Found ${allFiles.length} PDF(s) in /${FOLDER}\nTap a branch/pill to PREVIEW.`);
    applySearch();
  }catch(e){
    setStatus("ERROR: " + (e.message || e));
    allFiles = [];
    buildBranches([]);
  }
}

function applySearch(){
  const term = q.value.trim().toLowerCase();
  shownFiles = term ? allFiles.filter(f => displayName(f.name).toLowerCase().includes(term)) : allFiles;
  buildBranches(shownFiles);
}

/* --------- center swim pills ---------- */
function rand(a,b){ return a + Math.random()*(b-a); }

function resetSwimPills(R){
  const n = clamp(Math.round(R / 14), 10, 22);
  swimPills = [];
  for (let i=0;i<n;i++){
    const ang = rand(0, Math.PI*2);
    const rad = Math.sqrt(Math.random()) * (R * 0.70);
    const x = Math.cos(ang) * rad;
    const y = Math.sin(ang) * rad;

    const speed = rand(12, 28);
    const a2 = rand(0, Math.PI*2);
    const vx = Math.cos(a2) * speed;
    const vy = Math.sin(a2) * speed;

    const type = (i % 2 === 0) ? "capsule" : "tablet";
    const size = rand(R*0.055, R*0.085);
    const thick = size * rand(0.42, 0.55);
    swimPills.push({ x, y, vx, vy, rot: rand(-Math.PI, Math.PI), vr: rand(-0.9, 0.9), type, size, thick });
  }
}

function drawRoundedRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

function drawSwimPill(ctx, p){
  const L = p.size;
  const H = p.thick;

  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rot);

  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.filter = "blur(3px)";
  ctx.fillStyle = "rgba(17,24,39,0.45)";
  drawRoundedRect(ctx, -L/2+1, -H/2+2, L, H, H/2);
  ctx.fill();
  ctx.restore();

  if (p.type === "capsule"){
    const r = H/2;
    ctx.save();
    drawRoundedRect(ctx, -L/2, -H/2, L, H, r);
    ctx.clip();

    ctx.fillStyle = "rgba(17,24,39,0.14)";
    ctx.fillRect(-L/2, -H/2, L/2, H);
    ctx.fillStyle = "rgba(17,24,39,0.06)";
    ctx.fillRect(0, -H/2, L/2, H);

    const g = ctx.createLinearGradient(-L/2, -H/2, L/2, H/2);
    g.addColorStop(0, "rgba(255,255,255,0.55)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g;
    ctx.fillRect(-L/2, -H/2, L, H);

    ctx.restore();

    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(17,24,39,0.18)";
    drawRoundedRect(ctx, -L/2, -H/2, L, H, r);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "rgba(17,24,39,0.28)";
    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -H/2 + 2);
    ctx.lineTo(0,  H/2 - 2);
    ctx.stroke();
    ctx.restore();
  } else {
    const r = Math.min(14, H*0.38);
    ctx.save();
    ctx.fillStyle = "rgba(17,24,39,0.06)";
    drawRoundedRect(ctx, -L/2, -H/2, L, H, r);
    ctx.fill();

    const g2 = ctx.createLinearGradient(0, -H/2, 0, H/2);
    g2.addColorStop(0, "rgba(255,255,255,0.70)");
    g2.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g2;
    drawRoundedRect(ctx, -L/2, -H/2, L, H, r);
    ctx.fill();

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(17,24,39,0.16)";
    drawRoundedRect(ctx, -L/2, -H/2, L, H, r);
    ctx.stroke();

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = "rgba(17,24,39,0.26)";
    ctx.beginPath();
    ctx.moveTo(-L/2 + 6, 0);
    ctx.lineTo(L/2 - 6, 0);
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
}

function updateSwimPills(dt, t, R){
  const margin = Math.max(10, R * 0.12);
  const maxSpeed = 60;

  for (const p of swimPills){
    p.vx += Math.sin(t*0.8 + p.x*0.01) * 0.6 * dt;
    p.vy += Math.cos(t*0.7 + p.y*0.01) * 0.6 * dt;

    const sp = Math.hypot(p.vx, p.vy);
    if (sp > maxSpeed){
      const k = maxSpeed / sp;
      p.vx *= k; p.vy *= k;
    }

    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.rot += p.vr * dt;

    const ang = Math.atan2(p.y, p.x);
    const rr = wavyRadius(ang, t, R) - margin;
    const d  = Math.hypot(p.x, p.y);

    if (d > rr){
      const nx = p.x / (d || 1);
      const ny = p.y / (d || 1);

      p.x = nx * rr;
      p.y = ny * rr;

      const dot = p.vx*nx + p.vy*ny;
      p.vx = p.vx - 2*dot*nx;
      p.vy = p.vy - 2*dot*ny;

      p.vx += rand(-12, 12);
      p.vy += rand(-12, 12);
    }

    p.vx *= (1 - 0.06*dt);
    p.vy *= (1 - 0.06*dt);
  }
}

function animate(){
  const s1 = resizeCanvas(fx);
  resizeCanvas(lines);

  const ctxFx = fx.getContext("2d");
  const ctxLn = lines.getContext("2d");
  texPattern = buildTexturePattern(ctxFx);

  const w = s1.w, h = s1.h;
  const cx = w/2, cy = h/2;

  let t0 = performance.now();
  lastFrameT = t0;

  function frame(now){
    const t = (now - t0) / 1000;
    const dt = Math.min(0.033, Math.max(0.001, (now - lastFrameT) / 1000));
    lastFrameT = now;

    ctxFx.clearRect(0,0,w,h);
    ctxLn.clearRect(0,0,w,h);

    const geom = computeSafeGeometry(shownFiles.length || allFiles.length || 0);
    const R = geom.R;
    const pts = 180;

    if (!swimPills.length){
      resetSwimPills(R);
    } else {
      const want = clamp(Math.round(R / 14), 10, 22);
      if (Math.abs(swimPills.length - want) >= 4) resetSwimPills(R);
    }

    function blobPath(ctx){
      ctx.beginPath();
      for (let i=0; i<=pts; i++){
        const a = (i/pts) * Math.PI*2;
        const rr = wavyRadius(a, t, R);
        const x = cx + Math.cos(a) * rr;
        const y = cy + Math.sin(a) * rr;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.shadowColor = "rgba(17,24,39,0.12)";
    ctxFx.shadowBlur = 28;
    ctxFx.fillStyle = "rgba(17,24,39,0.02)";
    ctxFx.fill();
    ctxFx.restore();

    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.lineJoin = "round";
    ctxFx.lineCap = "round";
    ctxFx.lineWidth = R * 0.24;
    ctxFx.strokeStyle = texPattern || "rgba(17,24,39,0.06)";
    ctxFx.shadowColor = "rgba(17,24,39,0.08)";
    ctxFx.shadowBlur = 18;
    ctxFx.stroke();
    ctxFx.restore();

    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.clip();

    if (texPattern){
      ctxFx.globalAlpha = 0.18;
      ctxFx.fillStyle = texPattern;
      ctxFx.fillRect(cx - R*2.2, cy - R*2.2, R*4.4, R*4.4);
      ctxFx.globalAlpha = 1;
    } else {
      ctxFx.fillStyle = "rgba(17,24,39,0.02)";
      ctxFx.fillRect(cx - R*2.2, cy - R*2.2, R*4.4, R*4.4);
    }

    updateSwimPills(dt, t, R);
    ctxFx.save();
    ctxFx.translate(cx, cy);
    for (const p of swimPills) drawSwimPill(ctxFx, p);
    ctxFx.restore();

    const g = ctxFx.createRadialGradient(cx, cy, R*0.2, cx, cy, R*1.4);
    g.addColorStop(0, "rgba(255,255,255,0.55)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctxFx.fillStyle = g;
    ctxFx.fillRect(cx - R*2, cy - R*2, R*4, R*4);

    ctxFx.restore();

    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.strokeStyle = "rgba(17,24,39,0.78)";
    ctxFx.lineWidth = 1.25;
    ctxFx.stroke();
    ctxFx.restore();

    // branch lines
    ctxLn.save();
    ctxLn.lineWidth = 1;
    ctxLn.lineCap = "round";

    for (const b of branchObjs){
      const hovered = b.el.matches(":hover");
      const targetLen = hovered ? b.len : b.lenShort;

      const wob = 2.4 + b.seed * 3.0;
      const bend = Math.sin(t*0.9 + b.seed*10) * 0.9;
      const a = b.angleRad + Math.sin(t*0.35 + b.seed*9)*0.008;

      const rStart = wavyRadius(a, t, R) * 1.02;
      const xStart = cx + Math.cos(a) * rStart;
      const yStart = cy + Math.sin(a) * rStart;

      const segs = 10;
      ctxLn.beginPath();
      for (let i=0;i<=segs;i++){
        const u = i/segs;
        const lenNow = targetLen * u;

        const baseX = xStart + Math.cos(a) * lenNow;
        const baseY = yStart + Math.sin(a) * lenNow;

        const px = -Math.sin(a);
        const py =  Math.cos(a);

        const amp = (hovered ? 1.0 : 0.6) * wob * (0.3 + 0.7*Math.sin(u*Math.PI));
        const off = Math.sin(t*1.2 + u*6 + b.seed*20) * amp + bend * amp*0.6;

        const x = baseX + px * off;
        const y = baseY + py * off;

        if (i===0) ctxLn.moveTo(x,y); else ctxLn.lineTo(x,y);
      }

      ctxLn.strokeStyle = hovered ? "rgba(17,24,39,0.58)" : "rgba(17,24,39,0.18)";
      ctxLn.shadowColor = hovered ? "rgba(17,24,39,0.10)" : "rgba(17,24,39,0.06)";
      ctxLn.shadowBlur = hovered ? 16 : 10;
      ctxLn.stroke();
    }

    ctxLn.restore();

    rafId = requestAnimationFrame(frame);
  }

  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(frame);
}

document.getElementById("reload").addEventListener("click", async () => {
  await load();
  updateSidePanelOffset();
  requestAnimationFrame(updateSidePanelOffset);
});

q.addEventListener("input", applySearch);

window.addEventListener("resize", () => {
  updateSidePanelOffset();
  swimPills = [];
  applySearch();
  animate();
});

(async () => {
  await loadTexture();
  await load();

  updateSidePanelOffset();
  requestAnimationFrame(updateSidePanelOffset);

  animate();
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Orbit</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --line:rgba(17,24,39,.18);
      --lineHot:rgba(17,24,39,.55);
      --glow:rgba(17,24,39,.10);
      --btnBorder:rgba(17,24,39,.14);
      --btnHover:rgba(17,24,39,.06);
      --tipBg:rgba(255,255,255,.85);
      --tipBorder:rgba(17,24,39,.14);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow-x:hidden;
      min-height:100vh;
    }

    .topbar{
      position:fixed;
      top:0; left:0; right:0;
      padding:14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      z-index:20;
      background: linear-gradient(to bottom, rgba(255,255,255,.97), rgba(255,255,255,.75), rgba(255,255,255,0));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(17,24,39,.06);
    }
    .brand{display:flex; align-items:center; gap:10px; user-select:none;}
    .brand .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--ink);
      box-shadow: 0 0 18px var(--glow);
      opacity:.9;
    }
    .brand h1{
      margin:0;
      font-size:15px;
      letter-spacing:.08em;
      text-transform:uppercase;
      opacity:.9;
    }

    .actions{display:flex; gap:10px; flex-wrap:wrap}
    .btn{
      appearance:none;
      border:1px solid var(--btnBorder);
      background: rgba(17,24,39,.03);
      color: var(--ink);
      padding:10px 12px;
      border-radius:999px;
      cursor:pointer;
      text-decoration:none;
      font-weight:800;
      letter-spacing:.02em;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: var(--btnHover);
      border-color: rgba(17,24,39,.22);
    }
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn .miniDot{
      width:7px;height:7px;border-radius:50%;
      background: rgba(17,24,39,.85);
      box-shadow: 0 0 12px var(--glow);
      opacity:.9;
    }

    .sceneWrap{
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:80px 16px 30px;
    }

    /* ✅ no border */
    .scene{
      width:min(980px, 96vw);
      height:min(720px, 80vh);
      position:relative;
      border-radius:28px;
      overflow:hidden;
      border:none;
      background:
        radial-gradient(1100px 900px at 50% 45%, rgba(17,24,39,.05), rgba(255,255,255,0) 65%),
        rgba(255,255,255,1);
      box-shadow: 0 18px 60px rgba(17,24,39,.10);
    }

    /* super subtle dust */
    .scene:before{
      content:"";
      position:absolute; inset:-20%;
      background-image: radial-gradient(rgba(17,24,39,.08) 1px, transparent 1px);
      background-size: 3px 3px;
      opacity:.05;
      transform: rotate(7deg);
      pointer-events:none;
    }

    .hud{
      position:absolute;
      left:18px; bottom:16px;
      right:18px;
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      z-index:10;
      pointer-events:none;
    }
    .status{
      pointer-events:auto;
      max-width: 66%;
      padding:10px 12px;
      border-radius:16px;
      background: rgba(255,255,255,.78);
      color: rgba(17,24,39,.60);
      font-size:13px;
      white-space:pre-wrap;
      line-height:1.35;
      box-shadow: 0 0 0 1px rgba(17,24,39,.06) inset;
    }

    .controls{
      pointer-events:auto;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .input{
      border:1px solid rgba(17,24,39,.14);
      background: rgba(255,255,255,.75);
      color: var(--ink);
      padding:10px 12px;
      border-radius:999px;
      outline:none;
      min-width: 240px;
    }
    .input::placeholder{color: rgba(17,24,39,.45)}

    .smallBtn{
      border:1px solid rgba(17,24,39,.14);
      background: rgba(255,255,255,.75);
      color: var(--ink);
      padding:10px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
    }
    .smallBtn:hover{
      transform: translateY(-1px);
      background: rgba(17,24,39,.04);
      border-color: rgba(17,24,39,.22);
    }

    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}
    #fx{z-index:1}
    #lines{z-index:2}

    .centerLabel{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      text-align:center;
      z-index:7;
      pointer-events:none;
      user-select:none;
      width:min(360px, 80vw);
    }
    .centerLabel .title{
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-size:12px;
      opacity:.85;
    }
    .centerLabel .sub{
      margin-top:6px;
      font-size:12px;
      color: rgba(17,24,39,.60);
      opacity:.95;
    }

    .branches{position:absolute; inset:0; z-index:8;}

    .branch{
      position:absolute;
      left:50%;
      top:50%;
      width:0;
      height:0;
      transform: translate(-50%,-50%) rotate(var(--angle)) translateX(var(--r0));
      transform-origin: 0 0;
      pointer-events:auto;
    }

    .branch .hit{
      position:absolute;
      left:0;
      top:-18px;
      width: var(--len);
      height: 36px;
      cursor:pointer;
      background: transparent;
    }

    .branch .line{
      position:absolute;
      left:0;
      top:0;
      height:2px;
      width: var(--lenShort);
      background: var(--line);
      border-radius:999px;
      transform-origin:left center;
      box-shadow: 0 0 12px rgba(17,24,39,.06);
      transition: width .22s ease, background .22s ease, box-shadow .22s ease, opacity .22s ease;
      opacity:.9;
    }

    .branch .node{
      position:absolute;
      left: calc(var(--lenShort) - 11px);
      top: -11px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(255,255,255,.75);
      border:1px solid rgba(17,24,39,.14);
      box-shadow: 0 0 0 1px rgba(17,24,39,.02) inset, 0 0 18px rgba(17,24,39,.06);
      transform: scale(.25);
      opacity: 0;
      transition: transform .22s ease, opacity .22s ease, left .22s ease, background .22s ease, border-color .22s ease;
      display:grid;
      place-items:center;
      overflow:hidden;
    }
    .node::after{
      content:"";
      width: 7px; height: 7px;
      border-radius:50%;
      background: rgba(17,24,39,.85);
      box-shadow: 0 0 12px rgba(17,24,39,.10);
      opacity:.9;
    }

    .branch:hover .line{
      width: var(--len);
      background: var(--lineHot);
      box-shadow: 0 0 26px rgba(17,24,39,.12);
    }
    .branch:hover .node{
      left: calc(var(--len) - 11px);
      transform: scale(1);
      opacity: 1;
      background: rgba(255,255,255,.92);
      border-color: rgba(17,24,39,.26);
    }

    .tip{
      position:absolute;
      left: calc(var(--len) + 18px);
      top: -10px;
      transform: rotate(calc(var(--angle) * -1));
      transform-origin:left center;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--tipBorder);
      background: var(--tipBg);
      backdrop-filter: blur(6px);
      color: rgba(17,24,39,.85);
      font-size:12px;
      white-space:nowrap;
      max-width: 360px;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .branch:hover .tip{
      opacity:1;
      transform: rotate(calc(var(--angle) * -1)) translateY(-2px);
    }

    @media (hover:none) {
      .branch .line{ width: var(--len); background: var(--lineHot); }
      .branch .node{ left: calc(var(--len) - 11px); transform: scale(1); opacity:1; }
      .branch .tip{ opacity:1; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <h1>PDF ORBIT</h1>
    </div>
    <div class="actions">
      <a class="btn" href="./index2.html"><span class="miniDot"></span>Edit</a>
      <a class="btn"
         href="https://script.google.com/macros/s/AKfycbx1rGjbtnYu3YfKyvd__rBJP4dDbRM81Inmh5imX2-_D-IN1sxCcaQ4p3jGEmVAkBbWCQ/exec"
         target="_blank" rel="noopener noreferrer"><span class="miniDot"></span>Settings</a>
    </div>
  </div>

  <div class="sceneWrap">
    <div class="scene" id="scene">
      <canvas id="fx"></canvas>
      <canvas id="lines"></canvas>

      <div class="centerLabel" aria-hidden="true">
        <div class="title">PDF FILES</div>
        <div class="sub" id="countSub">Loading…</div>
      </div>

      <div class="branches" id="branches"></div>

      <div class="hud">
        <div class="status" id="status">Loading from GitHub…</div>
        <div class="controls">
          <input class="input" id="q" placeholder="Search filename..." />
          <button class="smallBtn" id="reload">Reload</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ======================
   CONFIG
   ====================== */
const OWNER  = "a860h040";
const REPO   = "Education";
const BRANCH = "main";
const FOLDER = "pdfs";
const API = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(FOLDER)}?ref=${encodeURIComponent(BRANCH)}`;

/* ✅ Put your roof/wall image in your repo and set the path here:
   Example: if you upload the image as /assets/roof.png -> "./assets/roof.png"
*/
const TEXTURE_URL = "./assets/roof.png";

/* ======================
   STATE
   ====================== */
const scene = document.getElementById("scene");
const fx = document.getElementById("fx");
const lines = document.getElementById("lines");
const statusEl = document.getElementById("status");
const branchesEl = document.getElementById("branches");
const q = document.getElementById("q");
const countSub = document.getElementById("countSub");

let allFiles = [];
let shownFiles = [];
let branchObjs = [];
let rafId = 0;

// texture pattern
let texImg = null;
let texPattern = null;

/* ======================
   HELPERS
   ====================== */
function setStatus(t){ statusEl.textContent = t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function hashStr(str){
  let h=2166136261;
  for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
  return ((h>>>0) % 100000) / 100000;
}
function resizeCanvas(c){
  const r = scene.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  c.width = Math.floor(r.width * dpr);
  c.height = Math.floor(r.height * dpr);
  const ctx = c.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { w:r.width, h:r.height };
}
function openUrl(url){ window.open(url, "_blank", "noopener,noreferrer"); }

/* ✅ "2025-..._76668a2b_Patient Education.pdf" -> "Patient Education" */
function displayName(full){
  const name = String(full || "");
  const noExt = name.toLowerCase().endsWith(".pdf") ? name.slice(0, -4) : name;
  const parts = noExt.split("_");
  if (parts.length >= 3) return parts.slice(2).join("_").trim() || noExt.trim();
  return noExt.trim();
}

/* wavy radius matches the blob outline */
function wavyRadius(angle, t, R){
  const n =
    Math.sin(angle*3 + t*0.9)*0.18 +
    Math.sin(angle*7 - t*1.3)*0.10 +
    Math.sin(angle*13 + t*0.6)*0.06;
  const spike = Math.max(0, Math.sin(angle*18 + t*1.2)) * 0.10;
  return R * (1 + n*0.35 + spike);
}

/* Create a smaller tiled pattern so it looks like “wall tiles” */
function buildTexturePattern(ctx){
  if (!texImg || !texImg.naturalWidth) return null;

  const scale = 0.32; // smaller = more tiles, adjust as you like
  const oc = document.createElement("canvas");
  oc.width = Math.max(64, Math.floor(texImg.naturalWidth * scale));
  oc.height = Math.max(64, Math.floor(texImg.naturalHeight * scale));
  const octx = oc.getContext("2d");
  octx.imageSmoothingEnabled = true;
  octx.drawImage(texImg, 0, 0, oc.width, oc.height);

  const p = ctx.createPattern(oc, "repeat");
  return p;
}

async function loadTexture(){
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => { texImg = img; resolve(true); };
    img.onerror = () => { texImg = null; resolve(false); };
    img.src = TEXTURE_URL;
  });
}

/* ======================
   BUILD BRANCHES (DOM)
   ====================== */
function buildBranches(files){
  branchesEl.innerHTML = "";
  branchObjs = [];

  const r = scene.getBoundingClientRect();

  // ✅ BIGGER center blob
  const R = Math.min(r.width, r.height) * 0.24;    // was 0.18
  const r0 = R * 1.05;                              // start from edge

  const MAX = 22;
  const list = files.slice(0, MAX);

  const baseLen = Math.min(r.width, r.height) * 0.34;
  const jitter = Math.min(r.width, r.height) * 0.08;
  const shortFactor = 0.52;
  const minAngleGap = 12;

  const golden = 137.50776405;
  const usedAngles = [];

  list.forEach((f, i) => {
    const seed = hashStr(f.name);
    let ang = (i * golden + seed * 30) % 360;

    for (let tries=0; tries<30; tries++){
      const ok = usedAngles.every(a => {
        const d = Math.abs(((ang - a + 540) % 360) - 180);
        return d >= minAngleGap;
      });
      if (ok) break;
      ang = (ang + 9) % 360;
    }
    usedAngles.push(ang);

    const len = clamp(baseLen + (seed - 0.5) * 2 * jitter, baseLen*0.8, baseLen*1.15);
    const lenShort = len * shortFactor;

    const nice = displayName(f.name);
    const url = f.download_url || f.raw_url;

    const branch = document.createElement("div");
    branch.className = "branch";
    branch.style.setProperty("--angle", ang + "deg");
    branch.style.setProperty("--len", len + "px");
    branch.style.setProperty("--lenShort", lenShort + "px");
    branch.style.setProperty("--r0", r0 + "px");

    const lineEl = document.createElement("div"); lineEl.className = "line";
    const nodeEl = document.createElement("div"); nodeEl.className = "node";
    const hitEl  = document.createElement("div"); hitEl.className  = "hit"; hitEl.title = nice;
    const tip    = document.createElement("div"); tip.className    = "tip"; tip.textContent = nice;

    hitEl.addEventListener("click", () => openUrl(url));
    nodeEl.addEventListener("click", () => openUrl(url));
    tip.addEventListener("click",   () => openUrl(url));
    hitEl.addEventListener("touchstart", (e)=>{ e.preventDefault(); openUrl(url); }, {passive:false});

    branch.appendChild(lineEl);
    branch.appendChild(nodeEl);
    branch.appendChild(hitEl);
    branch.appendChild(tip);
    branchesEl.appendChild(branch);

    branchObjs.push({
      angleRad: ang * Math.PI/180,
      len, lenShort,
      seed,
      el: branch
    });
  });

  countSub.textContent = files.length ? `${files.length} file(s)` : "No PDFs found";
}

/* ======================
   LOAD PDFs
   ====================== */
async function load(){
  setStatus("Loading from GitHub…");
  countSub.textContent = "Loading…";

  try{
    const r = await fetch(API);
    if (!r.ok){
      const text = await r.text();
      setStatus(`ERROR: GitHub API ${r.status}\n${text}\n\nIf your repo is PRIVATE, this will fail on GitHub Pages.`);
      allFiles = [];
      buildBranches([]);
      return;
    }

    const data = await r.json();
    allFiles = (Array.isArray(data) ? data : [])
      .filter(x => x && x.type === "file" && (x.name||"").toLowerCase().endsWith(".pdf"))
      .map(x => ({
        name: x.name,
        download_url: x.download_url,
        raw_url: `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${x.path}`
      }))
      .sort((a,b)=> displayName(a.name).localeCompare(displayName(b.name)));

    setStatus(`Found ${allFiles.length} PDF(s) in /${FOLDER}\nHover a branch to extend, then click the node to open.`);
    applySearch();
  }catch(e){
    setStatus("ERROR: " + (e.message || e));
    allFiles = [];
    buildBranches([]);
  }
}

function applySearch(){
  const term = q.value.trim().toLowerCase();
  shownFiles = term ? allFiles.filter(f => displayName(f.name).toLowerCase().includes(term)) : allFiles;
  buildBranches(shownFiles);
}

/* ======================
   ANIMATION
   ✅ center uses “roof/wall” texture + thicker “wall” ring
   ====================== */
function animate(){
  const s1 = resizeCanvas(fx);
  resizeCanvas(lines);

  const ctxFx = fx.getContext("2d");
  const ctxLn = lines.getContext("2d");

  // build pattern after canvas is ready
  texPattern = buildTexturePattern(ctxFx);

  const w = s1.w, h = s1.h;
  const cx = w/2, cy = h/2;

  let t0 = performance.now();

  function frame(now){
    const t = (now - t0) / 1000;

    ctxFx.clearRect(0,0,w,h);
    ctxLn.clearRect(0,0,w,h);

    // ✅ BIGGER center blob
    const R = Math.min(w,h) * 0.24;     // was 0.18
    const pts = 180;

    // ---------- center blob path ----------
    function blobPath(ctx){
      ctx.beginPath();
      for (let i=0; i<=pts; i++){
        const a = (i/pts) * Math.PI*2;
        const rr = wavyRadius(a, t, R);
        const x = cx + Math.cos(a) * rr;
        const y = cy + Math.sin(a) * rr;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    // soft outer shadow glow (no border)
    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.shadowColor = "rgba(17,24,39,0.12)";
    ctxFx.shadowBlur = 28;
    ctxFx.fillStyle = "rgba(17,24,39,0.02)";
    ctxFx.fill();
    ctxFx.restore();

    // ---------- textured “wall” ring ----------
    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.lineJoin = "round";
    ctxFx.lineCap = "round";
    ctxFx.lineWidth = R * 0.24; // “expand the walls”
    ctxFx.strokeStyle = texPattern || "rgba(17,24,39,0.06)";
    ctxFx.shadowColor = "rgba(17,24,39,0.08)";
    ctxFx.shadowBlur = 18;
    ctxFx.stroke();
    ctxFx.restore();

    // ---------- inner fill (light texture wash) ----------
    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.clip();
    // subtle texture fill
    if (texPattern){
      ctxFx.globalAlpha = 0.55;
      ctxFx.fillStyle = texPattern;
      ctxFx.fillRect(cx - R*2.2, cy - R*2.2, R*4.4, R*4.4);
      ctxFx.globalAlpha = 1;
    } else {
      ctxFx.fillStyle = "rgba(17,24,39,0.03)";
      ctxFx.fillRect(cx - R*2.2, cy - R*2.2, R*4.4, R*4.4);
    }
    // brighten center slightly
    const g = ctxFx.createRadialGradient(cx, cy, R*0.2, cx, cy, R*1.4);
    g.addColorStop(0, "rgba(255,255,255,0.65)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctxFx.fillStyle = g;
    ctxFx.fillRect(cx - R*2, cy - R*2, R*4, R*4);
    ctxFx.restore();

    // ---------- crisp outline ----------
    ctxFx.save();
    blobPath(ctxFx);
    ctxFx.strokeStyle = "rgba(17,24,39,0.78)";
    ctxFx.lineWidth = 1.25;
    ctxFx.shadowBlur = 0;
    ctxFx.stroke();
    ctxFx.restore();

    // ---------- inner ring ----------
    ctxFx.save();
    ctxFx.beginPath();
    ctxFx.arc(cx, cy, R*0.74, 0, Math.PI*2);
    ctxFx.strokeStyle = "rgba(17,24,39,0.18)";
    ctxFx.lineWidth = 1;
    ctxFx.stroke();
    ctxFx.restore();

    // ---------- animated branch lines (start from wavy edge) ----------
    ctxLn.save();
    ctxLn.lineWidth = 1;
    ctxLn.lineCap = "round";

    for (const b of branchObjs){
      const hovered = b.el.matches(":hover");
      const targetLen = hovered ? b.len : b.lenShort;

      const wob = 2.4 + b.seed * 3.0;
      const bend = Math.sin(t*0.9 + b.seed*10) * 0.9;
      const a = b.angleRad + Math.sin(t*0.35 + b.seed*9)*0.008;

      const rStart = wavyRadius(a, t, R) * 1.02;
      const xStart = cx + Math.cos(a) * rStart;
      const yStart = cy + Math.sin(a) * rStart;

      const segs = 10;
      ctxLn.beginPath();
      for (let i=0;i<=segs;i++){
        const u = i/segs;
        const lenNow = targetLen * u;

        const baseX = xStart + Math.cos(a) * lenNow;
        const baseY = yStart + Math.sin(a) * lenNow;

        const px = -Math.sin(a);
        const py =  Math.cos(a);

        const amp = (hovered ? 1.0 : 0.6) * wob * (0.3 + 0.7*Math.sin(u*Math.PI));
        const off = Math.sin(t*1.2 + u*6 + b.seed*20) * amp + bend * amp*0.6;

        const x = baseX + px * off;
        const y = baseY + py * off;

        if (i===0) ctxLn.moveTo(x,y); else ctxLn.lineTo(x,y);
      }

      ctxLn.strokeStyle = hovered ? "rgba(17,24,39,0.58)" : "rgba(17,24,39,0.18)";
      ctxLn.shadowColor = hovered ? "rgba(17,24,39,0.10)" : "rgba(17,24,39,0.06)";
      ctxLn.shadowBlur = hovered ? 16 : 10;
      ctxLn.stroke();
    }

    ctxLn.restore();
    rafId = requestAnimationFrame(frame);
  }

  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(frame);
}

/* ======================
   INIT
   ====================== */
document.getElementById("reload").addEventListener("click", load);
q.addEventListener("input", applySearch);

window.addEventListener("resize", () => {
  applySearch();
  animate();
});

(async () => {
  const ok = await loadTexture();
  await load();
  animate();
  if (!ok) setStatus(statusEl.textContent + "\n\nTexture not found. Upload the image to " + TEXTURE_URL);
})();
</script>
</body>
</html>

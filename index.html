<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Region Cutter (Redact + Export)</title>
  <style>
    :root { --bg:#0b1220; --panel:#0f1a33; --text:#e9eefc; --muted:#aab6da; --accent:#6ea8ff; --danger:#ff6e6e; }
    body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 18px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    header h1 { font-size:16px; margin:0; letter-spacing:.2px; }
    .row { display:flex; gap:12px; padding:12px 18px; flex-wrap:wrap; align-items:center; }
    .panel { background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px; }
    .controls { display:grid; grid-template-columns: 1fr; gap:10px; min-width:320px; max-width:520px; }
    .controls label { font-size:12px; color:var(--muted); }
    input[type="text"] { width:100%; padding:10px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.22); color:var(--text); }
    input[type="file"] { color:var(--muted); }
    button { padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--text); cursor:pointer; }
    button:hover { border-color: rgba(255,255,255,.22); }
    button.primary { background: rgba(110,168,255,.18); border-color: rgba(110,168,255,.35); }
    button.danger { background: rgba(255,110,110,.14); border-color: rgba(255,110,110,.35); }
    .small { font-size:12px; color:var(--muted); line-height:1.35; }
    .layout { display:grid; grid-template-columns: 360px 1fr; gap:12px; padding:0 18px 18px; }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }
    .viewer { position:relative; overflow:auto; max-height: calc(100vh - 170px); }
    .canvasWrap { position:relative; display:inline-block; margin:8px; }
    canvas { display:block; border-radius:10px; }
    #overlay { position:absolute; left:0; top:0; cursor:crosshair; }
    .metaBar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill { font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.18); color:var(--muted); }
    .list { display:flex; flex-direction:column; gap:8px; max-height: 320px; overflow:auto; padding-right:4px; }
    .item { display:flex; justify-content:space-between; gap:10px; align-items:center; border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.14); border-radius:10px; padding:8px 10px; }
    .item strong { font-size:12px; }
    .item span { font-size:12px; color:var(--muted); }
    .progress { height:10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); overflow:hidden; }
    .bar { height:100%; width:0%; background:rgba(110,168,255,.55); transition:width .15s; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
           font-size:12px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); color:var(--muted); }
    .errorBox { margin-top:10px; padding:10px; border-radius:10px; border:1px solid rgba(255,110,110,.35); background:rgba(255,110,110,.10); color:#ffd9d9; display:none; white-space:pre-wrap; }
  </style>
</head>
<body>
<header>
  <h1>PDF Region Cutter (Select → Remove → Export PDF)</h1>
  <div class="pill">Draw boxes to remove content</div>
  <div class="pill">Delete a box by clicking it, or using the list</div>
  <div class="pill">Shortcut: <span class="kbd">Esc</span> cancels a draw</div>
</header>

<div class="layout">
  <div class="panel controls">
    <div>
      <label>PDF URL (GitHub Pages URL recommended)</label>
      <input id="pdfUrl" type="text" placeholder="https://YOURNAME.github.io/yourrepo/your.pdf" />
      <div class="small">
        If you use GitHub "raw" links, CORS may block loading. Best: host the PDF on the same GitHub Pages site as this tool.
      </div>
    </div>

    <div class="metaBar">
      <button id="loadUrl" class="primary">Load from URL</button>
      <span class="small">or</span>
      <input id="fileInput" type="file" accept="application/pdf" />
    </div>

    <div class="metaBar">
      <button id="prev">◀ Prev</button>
      <button id="next">Next ▶</button>
      <span class="pill" id="pageInfo">Page: – / –</span>
    </div>

    <div class="metaBar">
      <label class="small" style="min-width:120px;">View scale</label>
      <button id="zoomOut">−</button>
      <span class="pill" id="zoomLabel">1.35×</span>
      <button id="zoomIn">+</button>
    </div>

    <div class="metaBar">
      <button id="clearPage" class="danger">Clear boxes (this page)</button>
      <button id="clearAll" class="danger">Clear boxes (all)</button>
    </div>

    <div>
      <label>Boxes on this page</label>
      <div class="list" id="boxList"></div>
    </div>

    <div>
      <label>Export</label>
      <div class="small">
        Export flattens each page into an image with removed regions filled white, keeping the exact look.
      </div>
      <div class="metaBar">
        <button id="export" class="primary">Export PDF</button>
        <span class="pill" id="status">Idle</span>
      </div>
      <div class="progress"><div class="bar" id="bar"></div></div>
      <div id="err" class="errorBox"></div>
    </div>
  </div>

  <div class="panel viewer">
    <div class="canvasWrap" id="canvasWrap" style="display:none;">
      <canvas id="pdfCanvas"></canvas>
      <canvas id="overlay"></canvas>
    </div>
    <div class="small" id="hint">
      Load a PDF to start. Then draw boxes over parts you want removed. Click a box to delete it.
    </div>
  </div>
</div>

<!-- PDF.js -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.min.js"></script>
<!-- pdf-lib -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

<script>
  // --- PDF.js worker ---
  // NOTE: if you open index.html via file://, browsers often block workers.
  // We handle that by disabling the worker when location.protocol === 'file:'.
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js";

  const state = {
    pdfJsDoc: null,
    pdfBytes: null,
    pageNum: 1,
    numPages: 0,
    scale: 1.35,
    rectsByPage: {},
    drawing: false,
    start: null,
    tempRect: null,
    renderToken: 0
  };

  const pdfUrlEl = document.getElementById("pdfUrl");
  const loadUrlBtn = document.getElementById("loadUrl");
  const fileInput = document.getElementById("fileInput");
  const prevBtn = document.getElementById("prev");
  const nextBtn = document.getElementById("next");
  const pageInfo = document.getElementById("pageInfo");
  const zoomOut = document.getElementById("zoomOut");
  const zoomIn = document.getElementById("zoomIn");
  const zoomLabel = document.getElementById("zoomLabel");
  const clearPage = document.getElementById("clearPage");
  const clearAll = document.getElementById("clearAll");
  const exportBtn = document.getElementById("export");
  const statusEl = document.getElementById("status");
  const barEl = document.getElementById("bar");
  const boxList = document.getElementById("boxList");
  const errEl = document.getElementById("err");

  const wrap = document.getElementById("canvasWrap");
  const hint = document.getElementById("hint");
  const pdfCanvas = document.getElementById("pdfCanvas");
  const overlay = document.getElementById("overlay");
  const pdfCtx = pdfCanvas.getContext("2d");
  const oCtx = overlay.getContext("2d");

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);
  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  function setStatus(txt) { statusEl.textContent = txt; }
  function setProgress(pct) { barEl.style.width = `${Math.max(0, Math.min(100, pct))}%`; }
  function showErr(msg) { errEl.style.display = "block"; errEl.textContent = msg; }
  function clearErr() { errEl.style.display = "none"; errEl.textContent = ""; }

  function ensurePageStore(p) {
    if (!state.rectsByPage[p]) state.rectsByPage[p] = [];
  }

  function canvasPoint(e) {
    const r = overlay.getBoundingClientRect();
    const x = (e.clientX - r.left) * (overlay.width / r.width);
    const y = (e.clientY - r.top) * (overlay.height / r.height);
    return {x, y};
  }

  function rectToNorm(rectPx) {
    const W = overlay.width, H = overlay.height;
    return {
      id: uid(),
      xN: clamp01(rectPx.x / W),
      yN: clamp01(rectPx.y / H),
      wN: clamp01(rectPx.w / W),
      hN: clamp01(rectPx.h / H)
    };
  }

  function normToPx(rN, W, H) {
    return { x: rN.xN * W, y: rN.yN * H, w: rN.wN * W, h: rN.hN * H };
  }

  function drawOverlay() {
    oCtx.clearRect(0,0,overlay.width, overlay.height);

    const rects = state.rectsByPage[state.pageNum] || [];
    rects.forEach((r, idx) => {
      const px = normToPx(r, overlay.width, overlay.height);
      oCtx.save();
      oCtx.fillStyle = "rgba(110,168,255,0.18)";
      oCtx.strokeStyle = "rgba(110,168,255,0.85)";
      oCtx.lineWidth = 2;
      oCtx.fillRect(px.x, px.y, px.w, px.h);
      oCtx.strokeRect(px.x, px.y, px.w, px.h);

      oCtx.fillStyle = "rgba(0,0,0,0.55)";
      oCtx.fillRect(px.x, Math.max(0, px.y - 18), 44, 18);
      oCtx.fillStyle = "white";
      oCtx.font = "12px system-ui";
      oCtx.fillText(`#${idx+1}`, px.x + 6, Math.max(12, px.y - 5));
      oCtx.restore();
    });

    if (state.tempRect) {
      const t = state.tempRect;
      oCtx.save();
      oCtx.fillStyle = "rgba(255,255,255,0.12)";
      oCtx.strokeStyle = "rgba(255,255,255,0.8)";
      oCtx.setLineDash([6,4]);
      oCtx.lineWidth = 2;
      oCtx.fillRect(t.x, t.y, t.w, t.h);
      oCtx.strokeRect(t.x, t.y, t.w, t.h);
      oCtx.restore();
    }
  }

  function refreshList() {
    ensurePageStore(state.pageNum);
    const rects = state.rectsByPage[state.pageNum];

    boxList.innerHTML = "";
    if (!rects.length) {
      boxList.innerHTML = `<div class="small">No boxes yet. Draw on the PDF to remove areas.</div>`;
      return;
    }

    rects.forEach((r, idx) => {
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div>
          <strong>Box #${idx+1}</strong><br/>
          <span>${(r.wN*100).toFixed(1)}% × ${(r.hN*100).toFixed(1)}%</span>
        </div>
        <button class="danger">Delete</button>
      `;
      el.querySelector("button").addEventListener("click", () => {
        state.rectsByPage[state.pageNum] = rects.filter(x => x.id !== r.id);
        drawOverlay(); refreshList();
      });
      boxList.appendChild(el);
    });
  }

  function hitTestRect(x, y) {
    const rects = state.rectsByPage[state.pageNum] || [];
    for (let i = rects.length - 1; i >= 0; i--) {
      const px = normToPx(rects[i], overlay.width, overlay.height);
      if (x >= px.x && x <= px.x + px.w && y >= px.y && y <= px.y + px.h) return rects[i];
    }
    return null;
  }

  async function loadPdfBytes(bytes) {
    clearErr();
    state.pdfBytes = bytes;

    // ✅ KEY FIX:
    // When opened via file://, disableWorker avoids "blank PDF" caused by worker restrictions.
    const loadingTask = pdfjsLib.getDocument({
      data: bytes,
      disableWorker: (location.protocol === "file:")
    });

    // Optional: password support
    loadingTask.onPassword = (updatePassword) => {
      const pw = prompt("This PDF is password-protected. Enter password:");
      updatePassword(pw || "");
    };

    loadingTask.onProgress = (p) => {
      if (p && p.total) setProgress((p.loaded / p.total) * 100);
    };

    state.pdfJsDoc = await loadingTask.promise;

    state.numPages = state.pdfJsDoc.numPages;
    state.pageNum = 1;
    state.rectsByPage = {};

    wrap.style.display = "inline-block";
    hint.style.display = "none";
    pageInfo.textContent = `Page: 1 / ${state.numPages}`;

    await renderPage();
    setProgress(0);
  }

  async function loadFromUrl(url) {
    clearErr();
    setStatus("Loading URL…");
    setProgress(0);

    const res = await fetch(url, { mode: "cors" });
    if (!res.ok) throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);

    const bytes = new Uint8Array(await res.arrayBuffer());
    await loadPdfBytes(bytes);
    setStatus("Ready");
  }

  async function renderPage() {
    if (!state.pdfJsDoc) return;

    const token = ++state.renderToken;
    setStatus("Rendering…");

    const page = await state.pdfJsDoc.getPage(state.pageNum);
    const viewport = page.getViewport({ scale: state.scale });

    pdfCanvas.width = Math.floor(viewport.width);
    pdfCanvas.height = Math.floor(viewport.height);
    overlay.width = pdfCanvas.width;
    overlay.height = pdfCanvas.height;

    const renderTask = page.render({ canvasContext: pdfCtx, viewport });
    await renderTask.promise;
    if (token !== state.renderToken) return;

    pageInfo.textContent = `Page: ${state.pageNum} / ${state.numPages}`;
    zoomLabel.textContent = `${state.scale.toFixed(2)}×`;

    ensurePageStore(state.pageNum);
    drawOverlay();
    refreshList();
    setStatus("Ready");
  }

  // ---- Draw Interaction ----
  overlay.addEventListener("mousedown", (e) => {
    if (!state.pdfJsDoc) return;

    const p = canvasPoint(e);
    const hit = hitTestRect(p.x, p.y);
    if (hit) {
      state.rectsByPage[state.pageNum] = (state.rectsByPage[state.pageNum] || []).filter(r => r.id !== hit.id);
      drawOverlay(); refreshList();
      return;
    }

    state.drawing = true;
    state.start = p;
    state.tempRect = { x: p.x, y: p.y, w: 0, h: 0 };
    drawOverlay();
  });

  overlay.addEventListener("mousemove", (e) => {
    if (!state.drawing) return;
    const p = canvasPoint(e);
    const x = Math.min(state.start.x, p.x);
    const y = Math.min(state.start.y, p.y);
    const w = Math.abs(p.x - state.start.x);
    const h = Math.abs(p.y - state.start.y);
    state.tempRect = { x, y, w, h };
    drawOverlay();
  });

  window.addEventListener("mouseup", () => {
    if (!state.drawing) return;
    state.drawing = false;

    const t = state.tempRect;
    state.tempRect = null;
    drawOverlay();

    if (!t || t.w < 6 || t.h < 6) return;

    ensurePageStore(state.pageNum);
    state.rectsByPage[state.pageNum].push(rectToNorm(t));
    drawOverlay();
    refreshList();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      state.drawing = false;
      state.tempRect = null;
      drawOverlay();
    }
  });

  // ---- Buttons ----
  loadUrlBtn.addEventListener("click", async () => {
    try {
      const url = pdfUrlEl.value.trim();
      if (!url) return alert("Paste a PDF URL first.");
      await loadFromUrl(url);
    } catch (err) {
      console.error(err);
      setStatus("Idle");
      setProgress(0);
      showErr(
        "Could not load PDF from URL.\n\n" +
        "Common causes:\n" +
        "1) CORS blocked (use GitHub Pages URL, not raw)\n" +
        "2) The URL is wrong or private\n\n" +
        "Error:\n" + err.message
      );
      alert("Could not load PDF. See the error box for details.");
    }
  });

  fileInput.addEventListener("change", async (e) => {
    try {
      const f = e.target.files?.[0];
      if (!f) return;
      setStatus("Loading file…");
      const bytes = new Uint8Array(await f.arrayBuffer());
      await loadPdfBytes(bytes);
      setStatus("Ready");
    } catch (err) {
      console.error(err);
      setStatus("Idle");
      setProgress(0);
      showErr("Failed to load file:\n" + err.message);
      alert("Failed to load file. See the error box for details.");
    }
  });

  prevBtn.addEventListener("click", async () => {
    if (!state.pdfJsDoc) return;
    if (state.pageNum <= 1) return;
    state.pageNum--;
    await renderPage();
  });

  nextBtn.addEventListener("click", async () => {
    if (!state.pdfJsDoc) return;
    if (state.pageNum >= state.numPages) return;
    state.pageNum++;
    await renderPage();
  });

  zoomOut.addEventListener("click", async () => {
    if (!state.pdfJsDoc) return;
    state.scale = Math.max(0.6, state.scale - 0.15);
    await renderPage();
  });

  zoomIn.addEventListener("click", async () => {
    if (!state.pdfJsDoc) return;
    state.scale = Math.min(3.0, state.scale + 0.15);
    await renderPage();
  });

  clearPage.addEventListener("click", () => {
    if (!state.pdfJsDoc) return;
    state.rectsByPage[state.pageNum] = [];
    drawOverlay(); refreshList();
  });

  clearAll.addEventListener("click", () => {
    if (!state.pdfJsDoc) return;
    state.rectsByPage = {};
    ensurePageStore(state.pageNum);
    drawOverlay(); refreshList();
  });

  // ---- Export (Flattened) ----
  exportBtn.addEventListener("click", async () => {
    if (!state.pdfJsDoc || !state.pdfBytes) return alert("Load a PDF first.");
    try {
      clearErr();
      setStatus("Preparing export…");
      setProgress(0);

      const { PDFDocument } = PDFLib;
      const orig = await PDFDocument.load(state.pdfBytes);
      const out = await PDFDocument.create();

      const exportScale = 2.0;

      for (let i = 1; i <= state.numPages; i++) {
        setStatus(`Exporting page ${i}/${state.numPages}…`);
        setProgress((i-1) / state.numPages * 100);

        const page = await state.pdfJsDoc.getPage(i);
        const viewport = page.getViewport({ scale: exportScale });

        const c = document.createElement("canvas");
        c.width = Math.floor(viewport.width);
        c.height = Math.floor(viewport.height);
        const ctx = c.getContext("2d");

        await page.render({ canvasContext: ctx, viewport }).promise;

        const rects = state.rectsByPage[i] || [];
        if (rects.length) {
          ctx.save();
          ctx.fillStyle = "white";
          rects.forEach(r => {
            const px = normToPx(r, c.width, c.height);
            ctx.fillRect(px.x, px.y, px.w, px.h);
          });
          ctx.restore();
        }

        const pngDataUrl = c.toDataURL("image/png");
        const pngBytes = await fetch(pngDataUrl).then(r => r.arrayBuffer());
        const pngImage = await out.embedPng(pngBytes);

        const origPage = orig.getPage(i - 1);
        const { width, height } = origPage.getSize();

        const outPage = out.addPage([width, height]);
        outPage.drawImage(pngImage, { x: 0, y: 0, width, height });
      }

      setStatus("Finalizing…");
      setProgress(100);

      const outBytes = await out.save();
      const blob = new Blob([outBytes], { type: "application/pdf" });

      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "edited_redacted.pdf";
      a.click();

      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
      setStatus("Done");
      setTimeout(() => setProgress(0), 800);
    } catch (err) {
      console.error(err);
      setStatus("Idle");
      setProgress(0);
      showErr("Export failed:\n" + err.message);
      alert("Export failed. See the error box for details.");
    }
  });
</script>
</body>
</html>

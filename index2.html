<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Cutter — Preview + Blank Pages + Spacer (Blank Section)</title>

  <!-- PDF.js (render) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.7.570/pdf.min.js"></script>
  <!-- jsPDF (export) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --text:#0b1020;
      --muted:#5c647c;
      --accent:#1f5cff;
      --danger:#d83434;
      --ok:#0f8a56;
      --border:rgba(0,0,0,.12);
      --shadow: 0 10px 30px rgba(0,0,0,.10);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: var(--bg);
      color: var(--text);
    }
    header{
      padding:18px 18px 10px;
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
      border-bottom:1px solid var(--border);
      background:#ffffff;
    }
    header h1{font-size:16px;margin:0;letter-spacing:.2px;}
    header p{
      margin:6px 0 0;
      font-size:12px;
      color:var(--muted);
      max-width:1100px;
      line-height:1.35;
    }

    .wrap{display:grid;grid-template-columns: 460px 1fr;gap:14px;padding:14px;}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

    .card{
      background:#ffffff;
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 12px 10px;
      background: #f6f7fb;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd b{font-size:13px;letter-spacing:.2px;}
    .card .bd{ padding:12px; }

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px dashed rgba(0,0,0,.25);
      background: #ffffff;
      color: var(--text);
    }

    button, input[type="range"]{ font: inherit; }
    button{
      border:1px solid var(--border);
      background: #ffffff;
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .04s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:hover{ background: #f3f5fb; border-color: rgba(0,0,0,.18); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: #e9efff;
      border-color: rgba(31,92,255,.40);
      color:#0b1a4a;
    }
    button.ok{
      background: #e7fff2;
      border-color: rgba(15,138,86,.45);
      color:#063b25;
    }
    button.danger{
      background: #ffecec;
      border-color: rgba(216,52,52,.45);
      color:#4a0b0b;
    }
    button[disabled]{ opacity:.5; cursor:not-allowed; transform:none !important; }

    .hint{
      font-size:12px;
      color: var(--muted);
      line-height:1.35;
      background: #f7f8fc;
      border:1px solid var(--border);
      border-radius: 12px;
      padding:10px 10px;
    }
    .hint b{color: var(--text)}
    .small{ font-size:12px; color: var(--muted); }
    .mono{
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    label.chk{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background: #ffffff;
      font-size:12px;
      color: var(--muted);
    }
    label.chk input{ transform: translateY(1px); }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 12px;
      font-size:12px;
      color: var(--muted);
      padding-top:10px;
      border-top: 1px solid var(--border);
      margin-top:10px;
    }
    .kv div:nth-child(2n){ color: var(--text); text-align:right; font-variant-numeric: tabular-nums; }

    .viewer{ padding:12px; }
    .toolbar{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom:10px;
    }
    .toolbar .left, .toolbar .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .toolbar .stat{ font-size:12px; color: var(--muted); }

    .canvasWrap{
      position:relative;
      width:100%;
      overflow:auto;
      border-radius: var(--radius);
      border:1px solid var(--border);
      background: #f3f4f6;
      max-height: calc(100vh - 170px);
      padding: 10px;
      scrollbar-gutter: stable both-edges;
    }
    .stage{ position:relative; display:inline-block; transform-origin: top left; }
    #pdfCanvas{ display:block; border-radius:8px; background:#ffffff; }
    #overlay{ position:absolute; left:0; top:0; pointer-events:auto; border-radius:8px; background:transparent !important; }

    .list{
      max-height: 150px;
      overflow:auto;
      border:1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
    }
    .listItem{
      padding:10px 10px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color: var(--muted);
    }
    .listItem:last-child{border-bottom:none}

    /* Modal preview */
    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .modal{
      width:min(1100px, 96vw);
      height:min(88vh, 920px);
      border-radius: 18px;
      border:1px solid var(--border);
      background: #ffffff;
      box-shadow: 0 18px 60px rgba(0,0,0,.25);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHd{
      padding:12px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--border);
      background: #f6f7fb;
    }
    .modalHd b{font-size:13px;}
    .modalBd{ padding:12px; height:100%; overflow:hidden; }
    .previewWrap{
      height:100%;
      border-radius:14px;
      border:1px solid var(--border);
      background:#f3f4f6;
      overflow:auto;
      padding:10px;
    }
    .previewStage{display:flex; flex-direction:column; gap:14px;}
    .previewPage{display:flex; flex-direction:column; gap:6px; align-items:center;}
    .previewPage .lbl{
      font-size:12px;
      color:#2b2f3d;
      background: #ffffff;
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius: 999px;
    }
    .previewCanvas{ border-radius:10px; background:#fff; border:1px solid rgba(0,0,0,.08); }
    .modalFooter{
      padding:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      border-top:1px solid var(--border);
      background: #f6f7fb;
    }
    .progress{ font-size:12px; color: var(--muted); display:flex; align-items:center; gap:8px; }
  </style>
</head>

<body>
<header>
  <div>
    <h1>PDF Cutter — preview edits + blank pages + blank spacer sections</h1>
    <p>
      <b>Delete</b> removes content and pulls text up. <b>Spacer</b> adds blank vertical space (does NOT delete text) so you can force better page separation.
      Download is only inside Preview.
    </p>
  </div>
</header>

<div class="wrap">
  <div class="card">
    <div class="hd"><b>Controls</b></div>
    <div class="bd">
      <div class="row">
        <input id="file" type="file" accept="application/pdf" />
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <button id="modeDraw" class="primary">Mode: Delete (cut)</button>
        <button id="modeSpacer">Mode: Spacer (blank section)</button>
        <button id="modeDelete">Mode: Click delete</button>
      </div>

      <div class="row">
        <button id="clearCuts" class="danger" disabled>Clear cuts (page)</button>
        <button id="clearSpacers" class="danger" disabled>Clear spacers (page)</button>
        <button id="clearAll" class="danger" disabled>Clear all</button>
      </div>

      <div style="height:10px"></div>

      <div class="hint">
        <b>Spacer mode:</b> drag a vertical band where you want extra blank space inserted in the final PDF.
        This helps push the next lines to the next page (better separation).
      </div>

      <div style="height:12px"></div>

      <div class="row">
        <label class="chk">
          <input id="blankHF" type="checkbox" checked />
          Keep header + footer BLANK in exported PDF
        </label>
      </div>

      <div class="row" style="align-items:center">
        <div class="small">Header blank:</div>
        <input id="headerPct" type="range" min="0" max="25" step="0.5" value="7" />
        <div id="headerPctLabel" class="mono small">7.0%</div>
      </div>

      <div class="row" style="align-items:center">
        <div class="small">Footer blank:</div>
        <input id="footerPct" type="range" min="0" max="25" step="0.5" value="7" />
        <div id="footerPctLabel" class="mono small">7.0%</div>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <label class="chk">
          <input id="smartBreaks" type="checkbox" checked />
          Smart page breaks (avoid splitting lines)
        </label>
      </div>

      <div style="height:10px"></div>

      <div class="row" style="align-items:center">
        <div class="small">Quality:</div>
        <input id="exportScale" type="range" min="1" max="3" step="0.25" value="2.5" />
        <div id="exportScaleLabel" class="mono small">2.50×</div>
      </div>

      <div style="height:12px"></div>

      <div class="row">
        <button id="previewBtn" class="primary" disabled>Preview</button>
      </div>

      <div class="kv">
        <div>Original pages</div><div id="metaPages" class="mono">—</div>
        <div>Current page</div><div id="metaPage" class="mono">—</div>
        <div>Cuts (this page)</div><div id="metaCuts" class="mono">—</div>
        <div>Spacers (this page)</div><div id="metaSpacers" class="mono">—</div>
        <div>Blank pages total</div><div id="metaBlankPages" class="mono">—</div>
      </div>

      <div style="height:12px"></div>

      <div class="small" style="margin-bottom:8px">Cuts (current page)</div>
      <div id="cutList" class="list"></div>

      <div style="height:12px"></div>

      <div class="small" style="margin-bottom:8px">Spacers (current page)</div>
      <div id="spacerList" class="list"></div>
    </div>
  </div>

  <div class="card">
    <div class="hd"><b>Editor</b></div>
    <div class="viewer">
      <div class="toolbar">
        <div class="left">
          <button id="prev" disabled>◀ Prev</button>
          <button id="next" disabled>Next ▶</button>
          <div class="stat" id="pageStat">No PDF loaded</div>
        </div>
        <div class="right">
          <button id="addBlankBefore" disabled class="primary">+ Blank Page Before</button>
          <button id="addBlankAfter" disabled class="primary">+ Blank Page After</button>
          <button id="removeBlankBefore" disabled>− Before</button>
          <button id="removeBlankAfter" disabled>− After</button>

          <button id="zoomOut" disabled>−</button>
          <div class="small">Zoom: <span id="zoomLabel" class="mono">100%</span></div>
          <button id="zoomIn" disabled>+</button>

          <button id="fitWidth" disabled class="primary">Fit Width</button>
          <button id="fitPage" disabled>Fit Page</button>
          <button id="actualSize" disabled>100%</button>
        </div>
      </div>

      <div class="canvasWrap" id="canvasWrap">
        <div class="stage" id="stage" style="display:none;">
          <canvas id="pdfCanvas"></canvas>
          <canvas id="overlay"></canvas>
        </div>

        <div id="emptyState" class="hint" style="max-width:720px;">
          <b>Upload a PDF to start</b><br/>
          Use modes to add cuts or spacers.
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modalBackdrop" id="previewModal">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Preview Edited PDF">
    <div class="modalHd">
      <b>Preview (final output)</b>
      <div class="row">
        <button id="closePreview">Close</button>
      </div>
    </div>
    <div class="modalBd">
      <div class="previewWrap" id="previewWrap">
        <div class="previewStage" id="previewStage"></div>
      </div>
    </div>
    <div class="modalFooter">
      <div class="progress"><span id="previewProgress">Ready</span></div>
      <div class="row">
        <button id="previewDownload" class="ok" disabled>Download</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const pdfjsLib = window['pdfjs-dist/build/pdf'];
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.7.570/pdf.worker.min.js';
  const { jsPDF } = window.jspdf;

  const elFile = document.getElementById('file');
  const canvasWrap = document.getElementById('canvasWrap');
  const elStage = document.getElementById('stage');
  const elEmpty = document.getElementById('emptyState');

  const pdfCanvas = document.getElementById('pdfCanvas');
  const overlay = document.getElementById('overlay');
  const ctx = pdfCanvas.getContext('2d');
  const octx = overlay.getContext('2d');

  const btnPrev = document.getElementById('prev');
  const btnNext = document.getElementById('next');
  const btnZoomIn = document.getElementById('zoomIn');
  const btnZoomOut = document.getElementById('zoomOut');
  const btnFitWidth = document.getElementById('fitWidth');
  const btnFitPage  = document.getElementById('fitPage');
  const btnActualSize = document.getElementById('actualSize');
  const zoomLabel = document.getElementById('zoomLabel');
  const pageStat = document.getElementById('pageStat');

  const btnModeDraw = document.getElementById('modeDraw');
  const btnModeSpacer = document.getElementById('modeSpacer');
  const btnModeDelete = document.getElementById('modeDelete');
  const btnClearCuts = document.getElementById('clearCuts');
  const btnClearSpacers = document.getElementById('clearSpacers');
  const btnClearAll = document.getElementById('clearAll');
  const previewBtn = document.getElementById('previewBtn');

  const exportScale = document.getElementById('exportScale');
  const exportScaleLabel = document.getElementById('exportScaleLabel');

  const blankHF = document.getElementById('blankHF');
  const headerPct = document.getElementById('headerPct');
  const footerPct = document.getElementById('footerPct');
  const headerPctLabel = document.getElementById('headerPctLabel');
  const footerPctLabel = document.getElementById('footerPctLabel');
  const smartBreaks = document.getElementById('smartBreaks');

  const metaPages = document.getElementById('metaPages');
  const metaPage = document.getElementById('metaPage');
  const metaCuts = document.getElementById('metaCuts');
  const metaSpacers = document.getElementById('metaSpacers');
  const metaBlankPages = document.getElementById('metaBlankPages');

  const cutList = document.getElementById('cutList');
  const spacerList = document.getElementById('spacerList');

  const addBlankBefore = document.getElementById('addBlankBefore');
  const addBlankAfter = document.getElementById('addBlankAfter');
  const removeBlankBefore = document.getElementById('removeBlankBefore');
  const removeBlankAfter = document.getElementById('removeBlankAfter');

  const previewModal = document.getElementById('previewModal');
  const previewWrap = document.getElementById('previewWrap');
  const previewStage = document.getElementById('previewStage');
  const closePreview = document.getElementById('closePreview');
  const previewProgress = document.getElementById('previewProgress');
  const previewDownload = document.getElementById('previewDownload');

  let pdfDoc = null;
  let pageNum = 1;
  let zoom = 1.0;
  let viewMode = 'width';

  const cutsByPage = new Map();
  const spacersByPage = new Map();
  const blanksBefore = new Map();
  const blanksAfter  = new Map();

  let mode = 'cut';
  let isDragging = false;
  let dragStart = null;
  let liveBand = null;
  let lastOutputPages = null;

  function invalidateOutputCache(){ lastOutputPages = null; }

  function setMode(m){
    mode = m;
    btnModeDraw.classList.remove('primary');
    btnModeSpacer.classList.remove('primary');
    btnModeDelete.classList.remove('primary');

    if (mode === 'cut'){
      btnModeDraw.classList.add('primary');
      overlay.style.cursor = 'ns-resize';
    } else if (mode === 'spacer'){
      btnModeSpacer.classList.add('primary');
      overlay.style.cursor = 'ns-resize';
    } else {
      btnModeDelete.classList.add('primary');
      overlay.style.cursor = 'pointer';
    }
  }

  function pageCuts(p = pageNum){
    if (!cutsByPage.has(p)) cutsByPage.set(p, []);
    return cutsByPage.get(p);
  }
  function pageSpacers(p = pageNum){
    if (!spacersByPage.has(p)) spacersByPage.set(p, []);
    return spacersByPage.get(p);
  }

  function getBlankCount(map, p){ return map.get(p) || 0; }
  function setBlankCount(map, p, v){ v<=0 ? map.delete(p) : map.set(p, v); }
  function totalBlankPages(){
    let n=0; for (const v of blanksBefore.values()) n+=v; for (const v of blanksAfter.values()) n+=v;
    return n;
  }

  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function pxBandToPct(bandPx){
    const h = overlay.height;
    return { yPct: clamp01(bandPx.y / h), hPct: clamp01(bandPx.h / h) };
  }
  function pctBandToPx(bandPct, h=overlay.height){
    return { y: bandPct.yPct * h, h: bandPct.hPct * h };
  }
  function normalizeBand(a, b){
    const y1 = Math.min(a.y, b.y);
    const y2 = Math.max(a.y, b.y);
    return { y: y1, h: (y2 - y1) };
  }
  function getMousePos(evt){
    const r = overlay.getBoundingClientRect();
    const x = (evt.clientX - r.left) * (overlay.width / r.width);
    const y = (evt.clientY - r.top) * (overlay.height / r.height);
    return { x, y };
  }

  function getInnerSize(el){
    const cs = getComputedStyle(el);
    const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    return { w: el.clientWidth - padX, h: el.clientHeight - padY };
  }
  function computeZoomFitWidth(baseViewport){
    const { w: availW } = getInnerSize(canvasWrap);
    return Math.max(0.2, Math.min(3, (availW / baseViewport.width) * 0.98));
  }
  function computeZoomFitPage(baseViewport){
    const { w: availW, h: availH } = getInnerSize(canvasWrap);
    return Math.max(0.2, Math.min(3, Math.min(availW / baseViewport.width, availH / baseViewport.height) * 0.98));
  }

  function mergeRanges(ranges){
    if (!ranges.length) return [];
    ranges.sort((a,b)=>a.y1-b.y1);
    const out = [ { y1: ranges[0].y1, y2: ranges[0].y2 } ];
    for (let i=1;i<ranges.length;i++){
      const cur = ranges[i];
      const last = out[out.length-1];
      if (cur.y1 <= last.y2) last.y2 = Math.max(last.y2, cur.y2);
      else out.push({y1:cur.y1, y2:cur.y2});
    }
    return out;
  }

  function updateHFLabels(){
    headerPctLabel.textContent = `${Number(headerPct.value).toFixed(1)}%`;
    footerPctLabel.textContent = `${Number(footerPct.value).toFixed(1)}%`;
  }

  function updateListsAndMeta(){
    if (!pdfDoc){
      metaPages.textContent = metaPage.textContent = metaCuts.textContent = metaSpacers.textContent = metaBlankPages.textContent = '—';
      cutList.innerHTML = spacerList.innerHTML = '';
      return;
    }
    metaPages.textContent = String(pdfDoc.numPages);
    metaPage.textContent = String(pageNum);
    metaCuts.textContent = String(pageCuts().length);
    metaSpacers.textContent = String(pageSpacers().length);
    metaBlankPages.textContent = String(totalBlankPages());

    btnClearCuts.disabled = pageCuts().length === 0;
    btnClearSpacers.disabled = pageSpacers().length === 0;
    btnClearAll.disabled = (pageCuts().length + pageSpacers().length + totalBlankPages()) === 0;

    removeBlankBefore.disabled = getBlankCount(blanksBefore, pageNum) === 0;
    removeBlankAfter.disabled = getBlankCount(blanksAfter, pageNum) === 0;

    const cuts = pageCuts();
    if (!cuts.length){
      cutList.innerHTML = `<div class="listItem"><span>No cuts</span><span class="mono">—</span></div>`;
    } else {
      cutList.innerHTML = '';
      cuts.forEach((c, idx) => {
        const item = document.createElement('div');
        item.className = 'listItem';
        const left = document.createElement('span');
        left.textContent = `Cut ${idx+1} (y:${(c.yPct*100).toFixed(1)}%, h:${(c.hPct*100).toFixed(1)}%)`;
        const right = document.createElement('button');
        right.textContent = 'Remove';
        right.className = 'danger';
        right.style.padding = '6px 10px';
        right.onclick = () => { cuts.splice(idx,1); invalidateOutputCache(); drawOverlay(); };
        item.appendChild(left); item.appendChild(right);
        cutList.appendChild(item);
      });
    }

    const sp = pageSpacers();
    if (!sp.length){
      spacerList.innerHTML = `<div class="listItem"><span>No spacers</span><span class="mono">—</span></div>`;
    } else {
      spacerList.innerHTML = '';
      sp.forEach((s, idx) => {
        const item = document.createElement('div');
        item.className = 'listItem';
        const left = document.createElement('span');
        left.textContent = `Spacer ${idx+1} (y:${(s.yPct*100).toFixed(1)}%, h:${(s.hPct*100).toFixed(1)}%)`;
        const right = document.createElement('button');
        right.textContent = 'Remove';
        right.className = 'danger';
        right.style.padding = '6px 10px';
        right.onclick = () => { sp.splice(idx,1); invalidateOutputCache(); drawOverlay(); };
        item.appendChild(left); item.appendChild(right);
        spacerList.appendChild(item);
      });
    }
  }

  function drawOverlay(){
    octx.clearRect(0, 0, overlay.width, overlay.height);

    if (blankHF.checked){
      const h = overlay.height;
      const topH = Math.round((Number(headerPct.value)/100) * h);
      const botH = Math.round((Number(footerPct.value)/100) * h);
      octx.save();
      octx.lineWidth = 2;
      octx.setLineDash([10,8]);
      octx.strokeStyle = 'rgba(31,92,255,0.85)';
      octx.fillStyle = 'rgba(31,92,255,0.10)';
      if (topH>0){ octx.fillRect(0,0,overlay.width,topH); octx.strokeRect(0,0,overlay.width,topH); }
      if (botH>0){ octx.fillRect(0,h-botH,overlay.width,botH); octx.strokeRect(0,h-botH,overlay.width,botH); }
      octx.restore();
    }

    for (const s of pageSpacers()){
      const px = pctBandToPx(s);
      octx.save();
      octx.lineWidth = 2;
      octx.setLineDash([6,6]);
      octx.strokeStyle = 'rgba(15,138,86,0.95)';
      octx.fillStyle = 'rgba(15,138,86,0.12)';
      octx.fillRect(0, px.y, overlay.width, px.h);
      octx.strokeRect(0, px.y, overlay.width, px.h);
      octx.restore();
    }

    for (const c of pageCuts()){
      const px = pctBandToPx(c);
      octx.save();
      octx.lineWidth = 2;
      octx.setLineDash([]);
      octx.strokeStyle = 'rgba(216,52,52,0.95)';
      octx.fillStyle = 'rgba(216,52,52,0.15)';
      octx.fillRect(0, px.y, overlay.width, px.h);
      octx.strokeRect(0, px.y, overlay.width, px.h);
      octx.restore();
    }

    if (liveBand){
      const color = (mode === 'spacer') ? 'rgba(15,138,86,0.95)' : 'rgba(31,92,255,0.95)';
      const fill  = (mode === 'spacer') ? 'rgba(15,138,86,0.12)' : 'rgba(31,92,255,0.12)';
      octx.save();
      octx.lineWidth = 2;
      octx.setLineDash([8,6]);
      octx.strokeStyle = color;
      octx.fillStyle = fill;
      octx.fillRect(0, liveBand.y, overlay.width, liveBand.h);
      octx.strokeRect(0, liveBand.y, overlay.width, liveBand.h);
      octx.restore();
    }

    updateListsAndMeta();
  }

  async function renderPage(){
    if (!pdfDoc) return;

    const page = await pdfDoc.getPage(pageNum);
    const base = page.getViewport({ scale: 1 });

    if (viewMode === 'width') zoom = computeZoomFitWidth(base);
    else if (viewMode === 'page') zoom = computeZoomFitPage(base);

    const dpr = window.devicePixelRatio || 1;
    const viewport = page.getViewport({ scale: zoom });

    pdfCanvas.width  = Math.floor(viewport.width * dpr);
    pdfCanvas.height = Math.floor(viewport.height * dpr);
    pdfCanvas.style.width  = `${Math.floor(viewport.width)}px`;
    pdfCanvas.style.height = `${Math.floor(viewport.height)}px`;

    overlay.width  = pdfCanvas.width;
    overlay.height = pdfCanvas.height;
    overlay.style.width  = pdfCanvas.style.width;
    overlay.style.height = pdfCanvas.style.height;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, viewport.width, viewport.height);
    await page.render({ canvasContext: ctx, viewport }).promise;

    elStage.style.display = '';
    elEmpty.style.display = 'none';

    btnPrev.disabled = pageNum <= 1;
    btnNext.disabled = pageNum >= pdfDoc.numPages;

    btnZoomIn.disabled = btnZoomOut.disabled = btnFitWidth.disabled = btnFitPage.disabled = btnActualSize.disabled = false;
    addBlankBefore.disabled = addBlankAfter.disabled = false;

    zoomLabel.textContent = `${Math.round(zoom * 100)}%`;
    pageStat.textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;

    drawOverlay();
  }

  async function loadPdfFromFile(file){
    const buf = await file.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: buf }).promise;

    pageNum = 1;
    zoom = 1.0;
    viewMode = 'width';

    cutsByPage.clear();
    spacersByPage.clear();
    blanksBefore.clear();
    blanksAfter.clear();
    invalidateOutputCache();

    await renderPage();
  }

  overlay.addEventListener('mousedown', (evt) => {
    if (!pdfDoc) return;
    const pos = getMousePos(evt);

    if (mode === 'cut' || mode === 'spacer'){
      isDragging = true;
      dragStart = pos;
      liveBand = { y: pos.y, h: 0 };
      drawOverlay();
      return;
    }

    const y = pos.y;
    const cuts = pageCuts();
    for (let i = cuts.length - 1; i >= 0; i--){
      const px = pctBandToPx(cuts[i]);
      if (y >= px.y && y <= px.y + px.h){
        cuts.splice(i, 1);
        invalidateOutputCache();
        drawOverlay();
        return;
      }
    }
    const sp = pageSpacers();
    for (let i = sp.length - 1; i >= 0; i--){
      const px = pctBandToPx(sp[i]);
      if (y >= px.y && y <= px.y + px.h){
        sp.splice(i, 1);
        invalidateOutputCache();
        drawOverlay();
        return;
      }
    }
  });

  window.addEventListener('mousemove', (evt) => {
    if (!pdfDoc) return;
    if (!isDragging) return;
    if (!(mode === 'cut' || mode === 'spacer')) return;

    const pos = getMousePos(evt);
    const band = normalizeBand({y: dragStart.y}, {y: pos.y});
    liveBand = { y: band.y, h: band.h };
    drawOverlay();
  });

  window.addEventListener('mouseup', () => {
    if (!pdfDoc) return;
    if (!isDragging) return;
    if (!(mode === 'cut' || mode === 'spacer')) return;

    isDragging = false;
    const minPx = 10 * (window.devicePixelRatio || 1);
    if (liveBand && liveBand.h >= minPx){
      const pct = pxBandToPct(liveBand);
      if (mode === 'cut') pageCuts().push(pct);
      if (mode === 'spacer') pageSpacers().push(pct);
      invalidateOutputCache();
    }
    liveBand = null;
    dragStart = null;
    drawOverlay();
  });

  btnModeDraw.onclick = () => setMode('cut');
  btnModeSpacer.onclick = () => setMode('spacer');
  btnModeDelete.onclick = () => setMode('clickDelete');

  btnPrev.onclick = async () => { if (!pdfDoc || pageNum<=1) return; pageNum -= 1; await renderPage(); };
  btnNext.onclick = async () => { if (!pdfDoc || pageNum>=pdfDoc.numPages) return; pageNum += 1; await renderPage(); };

  btnZoomIn.onclick = async () => { if(!pdfDoc) return; viewMode='manual'; zoom=Math.min(3, zoom+0.15); await renderPage(); };
  btnZoomOut.onclick = async () => { if(!pdfDoc) return; viewMode='manual'; zoom=Math.max(0.5, zoom-0.15); await renderPage(); };
  btnFitWidth.onclick = async () => { if(!pdfDoc) return; viewMode='width'; await renderPage(); };
  btnFitPage.onclick  = async () => { if(!pdfDoc) return; viewMode='page'; await renderPage(); };
  btnActualSize.onclick = async () => { if(!pdfDoc) return; viewMode='manual'; zoom=1.0; await renderPage(); };

  btnClearCuts.onclick = () => { if (!pdfDoc) return; cutsByPage.set(pageNum, []); invalidateOutputCache(); drawOverlay(); };
  btnClearSpacers.onclick = () => { if (!pdfDoc) return; spacersByPage.set(pageNum, []); invalidateOutputCache(); drawOverlay(); };
  btnClearAll.onclick = () => {
    if (!pdfDoc) return;
    cutsByPage.clear(); spacersByPage.clear(); blanksBefore.clear(); blanksAfter.clear();
    invalidateOutputCache(); drawOverlay();
  };

  addBlankBefore.onclick = () => { if (!pdfDoc) return; setBlankCount(blanksBefore, pageNum, getBlankCount(blanksBefore, pageNum) + 1); invalidateOutputCache(); drawOverlay(); };
  addBlankAfter.onclick  = () => { if (!pdfDoc) return; setBlankCount(blanksAfter,  pageNum, getBlankCount(blanksAfter,  pageNum) + 1); invalidateOutputCache(); drawOverlay(); };
  removeBlankBefore.onclick = () => { if (!pdfDoc) return; const cur=getBlankCount(blanksBefore,pageNum); if(cur>0) setBlankCount(blanksBefore,pageNum,cur-1); invalidateOutputCache(); drawOverlay(); };
  removeBlankAfter.onclick  = () => { if (!pdfDoc) return; const cur=getBlankCount(blanksAfter,pageNum);  if(cur>0) setBlankCount(blanksAfter,pageNum,cur-1);  invalidateOutputCache(); drawOverlay(); };

  exportScale.addEventListener('input', () => { exportScaleLabel.textContent = `${Number(exportScale.value).toFixed(2)}×`; invalidateOutputCache(); });
  blankHF.addEventListener('change', () => { invalidateOutputCache(); drawOverlay(); });
  headerPct.addEventListener('input', () => { updateHFLabels(); invalidateOutputCache(); drawOverlay(); });
  footerPct.addEventListener('input', () => { updateHFLabels(); invalidateOutputCache(); drawOverlay(); });
  smartBreaks.addEventListener('change', () => { invalidateOutputCache(); });

  window.addEventListener('resize', async () => { if(!pdfDoc) return; if(viewMode==='width'||viewMode==='page') await renderPage(); });

  function findSmartBreakHeight(srcCtx, targetW, startY, maxH){
    const boundaryY = startY + maxH;
    const minKeep = 90;
    const keepAwayBottom = 18;
    const windowH = Math.min(280, maxH - 20);
    if (windowH < 80 || maxH < minKeep) return maxH;

    const yTop = Math.max(startY + 30, boundaryY - windowH);
    const yBot = boundaryY - keepAwayBottom;
    if (yBot <= yTop) return maxH;

    const xMargin = Math.floor(targetW * 0.07);
    const scanW = Math.max(80, targetW - 2 * xMargin);
    const scanH = yBot - yTop;

    const img = srcCtx.getImageData(xMargin, yTop, scanW, scanH).data;

    const stepX = 4;
    const cols = Math.floor(scanW / stepX);
    const ink = new Float32Array(scanH);

    for (let row = 0; row < scanH; row++){
      let sum = 0;
      const rowOff = row * scanW * 4;
      for (let x = 0; x < scanW; x += stepX){
        const i = rowOff + x * 4;
        const r = img[i], g = img[i+1], b = img[i+2];
        const lum = (0.2126*r + 0.7152*g + 0.0722*b);
        const d = Math.max(0, 242 - lum);
        sum += d;
      }
      ink[row] = sum / Math.max(1, cols);
    }

    const sm = new Float32Array(scanH);
    const rad = 3;
    for (let i = 0; i < scanH; i++){
      let s = 0, c = 0;
      for (let k = -rad; k <= rad; k++){
        const j = i + k;
        if (j >= 0 && j < scanH){ s += ink[j]; c++; }
      }
      sm[i] = s / c;
    }

    const arr = Array.from(sm).sort((a,b)=>a-b);
    const thr = arr[Math.floor(arr.length * 0.08)] ?? sm[0];

    let bestLen = 0, bestMid = -1, runStart = -1;
    for (let i=0;i<scanH;i++){
      const low = sm[i] <= thr;
      if (low && runStart === -1) runStart = i;
      if (!low && runStart !== -1){
        const runEnd = i-1;
        const len = runEnd-runStart+1;
        if (len>bestLen){ bestLen=len; bestMid=Math.floor((runStart+runEnd)/2); }
        runStart = -1;
      }
    }
    if (runStart !== -1){
      const runEnd = scanH-1;
      const len = runEnd-runStart+1;
      if (len>bestLen){ bestLen=len; bestMid=Math.floor((runStart+runEnd)/2); }
    }

    if (bestMid !== -1 && bestLen >= 6){
      const breakY = yTop + bestMid;
      const breakH = breakY - startY;
      const safeBreakH = Math.max(minKeep, breakH - 6);
      if (safeBreakH >= minKeep && safeBreakH <= maxH) return safeBreakH;
    }
    return maxH;
  }

  async function generateEditedPages(){
    const exp = Number(exportScale.value) || 2.5;

    const firstPage = await pdfDoc.getPage(1);
    const firstVp = firstPage.getViewport({ scale: exp });
    const targetW = Math.floor(firstVp.width);
    const targetH = Math.floor(firstVp.height);
    const orientation = targetW >= targetH ? 'landscape' : 'portrait';

    const headerPx = (blankHF.checked ? Math.round((Number(headerPct.value)/100) * targetH) : 0);
    const footerPx = (blankHF.checked ? Math.round((Number(footerPct.value)/100) * targetH) : 0);

    const bodyTop = headerPx;
    const bodyBottom = targetH - footerPx;
    const bodyH = Math.max(1, bodyBottom - bodyTop);
    if (bodyH < 140) throw new Error('Header/Footer blank margins are too large.');

    const outCan = document.createElement('canvas');
    outCan.width = targetW;
    outCan.height = targetH;
    const outCtx = outCan.getContext('2d');

    function clearOut(){
      outCtx.fillStyle = '#ffffff';
      outCtx.fillRect(0, 0, targetW, targetH);
    }

    let outBodyY = 0;
    const pageImages = [];
    clearOut();

    function pushCurrentPage(){
      pageImages.push(outCan.toDataURL('image/jpeg', 0.95));
      clearOut();
      outBodyY = 0;
    }
    function pushBlankWholePage(){
      clearOut();
      pageImages.push(outCan.toDataURL('image/jpeg', 0.95));
      clearOut();
      outBodyY = 0;
    }
    function drawToBody(srcCanvas, srcY, takeH){
      outCtx.drawImage(srcCanvas, 0, srcY, targetW, takeH, 0, bodyTop + outBodyY, targetW, takeH);
    }

    function consumeBlank(blankH){
      let remaining = blankH;
      while (remaining > 0){
        const space = bodyH - outBodyY;
        if (space <= 0){ pushCurrentPage(); continue; }
        if (remaining <= space){
          outBodyY += remaining;
          remaining = 0;
        } else {
          outBodyY += space;
          remaining -= space;
          pushCurrentPage();
        }
      }
    }

    function insertBlankPages(count){
      if (count <= 0) return;
      if (outBodyY > 0) pushCurrentPage();
      for (let i=0;i<count;i++) pushBlankWholePage();
    }

    function isInDeleted(y, deleted){
      for (const r of deleted){ if (y >= r.y1 && y < r.y2) return true; }
      return false;
    }

    for (let p = 1; p <= pdfDoc.numPages; p++){
      insertBlankPages(getBlankCount(blanksBefore, p));

      const page = await pdfDoc.getPage(p);
      const vp = page.getViewport({ scale: exp });

      const srcCan = document.createElement('canvas');
      srcCan.width = Math.floor(vp.width);
      srcCan.height = Math.floor(vp.height);
      const srcCtx = srcCan.getContext('2d');

      srcCtx.fillStyle = '#ffffff';
      srcCtx.fillRect(0,0,srcCan.width,srcCan.height);
      await page.render({ canvasContext: srcCtx, viewport: vp }).promise;

      let src = srcCan;
      if (srcCan.width !== targetW || srcCan.height !== targetH){
        const scaled = document.createElement('canvas');
        scaled.width = targetW;
        scaled.height = targetH;
        const sctx = scaled.getContext('2d');
        sctx.fillStyle = '#ffffff';
        sctx.fillRect(0,0,targetW,targetH);
        sctx.drawImage(srcCan, 0,0, srcCan.width,srcCan.height, 0,0, targetW,targetH);
        src = scaled;
      }
      const normCtx = src.getContext('2d');

      const del = [];
      if (blankHF.checked){
        if (headerPx > 0) del.push({ y1: 0, y2: headerPx });
        if (footerPx > 0) del.push({ y1: targetH - footerPx, y2: targetH });
      }
      for (const c of (cutsByPage.get(p) || [])){
        const y1 = Math.max(0, Math.floor(c.yPct * targetH));
        const y2 = Math.min(targetH, Math.ceil((c.yPct + c.hPct) * targetH));
        if (y2 > y1) del.push({ y1, y2 });
      }
      const deleted = mergeRanges(del);

      const kept = [];
      let cursor = 0;
      for (const r of deleted){
        if (r.y1 > cursor) kept.push({ y1: cursor, y2: r.y1 });
        cursor = Math.max(cursor, r.y2);
      }
      if (cursor < targetH) kept.push({ y1: cursor, y2: targetH });

      const spacers = (spacersByPage.get(p) || [])
        .map(s => ({
          y1: Math.max(0, Math.floor(s.yPct * targetH)),
          h:  Math.max(1, Math.ceil(s.hPct * targetH))
        }))
        .filter(s => s.h > 0 && s.y1 >= 0 && s.y1 <= targetH)
        .filter(s => !isInDeleted(s.y1, deleted))
        .sort((a,b)=>a.y1-b.y1);

      let spIdx = 0;

      for (const seg of kept){
        let segY = seg.y1;
        let segEnd = seg.y2;

        while (spIdx < spacers.length && spacers[spIdx].y1 < segY) spIdx++;

        while (spIdx < spacers.length && spacers[spIdx].y1 > segY && spacers[spIdx].y1 < segEnd){
          const sp = spacers[spIdx];

          let partY = segY;
          let partRemaining = sp.y1 - segY;

          while (partRemaining > 0){
            const bodySpace = bodyH - outBodyY;
            if (partRemaining <= bodySpace){
              drawToBody(src, partY, partRemaining);
              outBodyY += partRemaining;
              partY += partRemaining;
              partRemaining = 0;
              if (outBodyY >= bodyH) pushCurrentPage();
            } else {
              let take = bodySpace;
              if (smartBreaks.checked && bodySpace >= 200){
                take = findSmartBreakHeight(normCtx, targetW, partY, bodySpace);
              }
              drawToBody(src, partY, take);
              outBodyY += take;
              partY += take;
              partRemaining -= take;
              if (partRemaining > 0) pushCurrentPage();
              else if (outBodyY >= bodyH) pushCurrentPage();
            }
          }

          consumeBlank(sp.h);
          segY = sp.y1;
          spIdx++;
        }

        let segRemaining = segEnd - segY;
        while (segRemaining > 0){
          const bodySpace = bodyH - outBodyY;

          if (segRemaining <= bodySpace){
            drawToBody(src, segY, segRemaining);
            outBodyY += segRemaining;
            segY += segRemaining;
            segRemaining = 0;
            if (outBodyY >= bodyH) pushCurrentPage();
            continue;
          }

          let take = bodySpace;
          if (smartBreaks.checked && bodySpace >= 200){
            take = findSmartBreakHeight(normCtx, targetW, segY, bodySpace);
          }
          drawToBody(src, segY, take);
          outBodyY += take;
          segY += take;
          segRemaining -= take;

          if (segRemaining > 0) pushCurrentPage();
          else if (outBodyY >= bodyH) pushCurrentPage();
        }
      }

      insertBlankPages(getBlankCount(blanksAfter, p));
    }

    if (outBodyY > 0) pushCurrentPage();

    return { pages: pageImages, w: targetW, h: targetH, orientation };
  }

  function openPreview(){ previewModal.style.display = 'flex'; document.body.style.overflow = 'hidden'; }
  function closePreviewModal(){ previewModal.style.display = 'none'; document.body.style.overflow = ''; }
  closePreview.onclick = closePreviewModal;
  previewModal.addEventListener('click', (e) => { if (e.target === previewModal) closePreviewModal(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && previewModal.style.display === 'flex') closePreviewModal(); });

  function renderPreviewPages(pages, w, h){
    previewStage.innerHTML = '';
    const maxW = Math.min(900, previewWrap.clientWidth - 30);
    const scale = Math.min(1, maxW / w);

    pages.forEach((img, idx) => {
      const pageBox = document.createElement('div');
      pageBox.className = 'previewPage';

      const lbl = document.createElement('div');
      lbl.className = 'lbl';
      lbl.textContent = `Output Page ${idx + 1}`;

      const c = document.createElement('canvas');
      c.className = 'previewCanvas';
      c.width = Math.floor(w * scale);
      c.height = Math.floor(h * scale);

      const cctx = c.getContext('2d');
      const im = new Image();
      im.onload = () => {
        cctx.fillStyle = '#ffffff';
        cctx.fillRect(0,0,c.width,c.height);
        cctx.drawImage(im, 0, 0, c.width, c.height);
      };
      im.src = img;

      pageBox.appendChild(lbl);
      pageBox.appendChild(c);
      previewStage.appendChild(pageBox);
    });
  }

  previewBtn.onclick = async () => {
    if (!pdfDoc) return;
    previewBtn.disabled = true;
    previewBtn.textContent = 'Rendering...';
    previewDownload.disabled = true;
    previewProgress.textContent = 'Rendering preview...';
    openPreview();

    try{
      if (!lastOutputPages) lastOutputPages = await generateEditedPages();
      renderPreviewPages(lastOutputPages.pages, lastOutputPages.w, lastOutputPages.h);
      previewProgress.textContent = `Done — ${lastOutputPages.pages.length} output pages`;
      previewDownload.disabled = false;
    } catch (err){
      console.error(err);
      previewProgress.textContent = 'Preview failed.';
      previewStage.innerHTML = `<div class="hint"><b>Preview failed</b><br/>${String(err.message || err)}</div>`;
    } finally {
      previewBtn.disabled = false;
      previewBtn.textContent = 'Preview';
    }
  };

  previewDownload.onclick = async () => {
    if (!pdfDoc) return;
    previewDownload.disabled = true;
    previewDownload.textContent = 'Building PDF...';
    previewProgress.textContent = 'Building PDF...';

    try{
      if (!lastOutputPages) lastOutputPages = await generateEditedPages();
      const { pages, w, h, orientation } = lastOutputPages;

      const outPdf = new jsPDF({ orientation, unit:'px', format:[w, h], compress:true });
      pages.forEach((img, i) => {
        if (i > 0) outPdf.addPage([w, h], orientation);
        outPdf.addImage(img, 'JPEG', 0, 0, w, h, undefined, 'FAST');
      });
      outPdf.save('edited_previewed.pdf');
      previewProgress.textContent = 'Downloaded.';
    } catch (err){
      console.error(err);
      previewProgress.textContent = 'Download failed.';
      alert('Download failed. Try increasing quality or lowering header/footer %.');
    } finally {
      previewDownload.disabled = false;
      previewDownload.textContent = 'Download';
    }
  };

  elFile.onchange = async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    if (file.type !== 'application/pdf'){ alert('Please upload a PDF file.'); return; }

    setMode('cut');
    previewBtn.disabled = true;

    try{
      await loadPdfFromFile(file);
      btnPrev.disabled = false;
      btnNext.disabled = false;
      btnClearCuts.disabled = false;
      btnClearSpacers.disabled = false;
      btnClearAll.disabled = false;
      previewBtn.disabled = false;
      updateListsAndMeta();
    } catch (err){
      console.error(err);
      alert('Could not load PDF.');
    }
  };

  exportScaleLabel.textContent = `${Number(exportScale.value).toFixed(2)}×`;
  updateHFLabels();
  setMode('cut');
  cutList.innerHTML = `<div class="listItem"><span>No PDF loaded</span><span class="mono">—</span></div>`;
  spacerList.innerHTML = `<div class="listItem"><span>No PDF loaded</span><span class="mono">—</span></div>`;
})();
</script>
</body>
</html>
